// Generated by CoffeeScript 1.7.1
(function() {
  var BuiltinFunction, LogoVM, UserFunction, op;

  op = require('./opcodes');

  BuiltinFunction = require('./codeObj').BuiltinFunction;

  UserFunction = require('./codeObj').UserFunction;

  LogoVM = (function() {
    function LogoVM(codeObj) {
      this.codeObj = codeObj;
      this.consts = this.codeObj.consts;
      this.globals = this._initGlobals();
    }

    LogoVM.prototype._initGlobals = function() {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.codeObj.globalNames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(void 0);
      }
      return _results;
    };

    LogoVM.prototype.run = function() {
      return this._run(this.codeObj.code);
    };

    LogoVM.prototype._run = function(code, localContext, funcName) {
      var i, len, pc, stack, _args, _callee, _func, _global, _local, _name, _x, _y;
      if (localContext == null) {
        localContext = this.globals;
      }
      stack = [];
      pc = 0;
      len = code.length;
      while (pc < len) {
        switch (code[pc]) {
          case op.HALT:
            return 0;
          case op.POP:
            stack.pop();
            break;
          case op.LDCONST:
            stack.push(this.consts[code[++pc]]);
            break;
          case op.LDLOCAL:
            _local = localContext[code[++pc]];
            if (typeof _local === 'undefined') {
              _name = this.codeObj.localNames[funcName][code[pc]];
              throw new Error("" + _name + " is not defined");
            }
            stack.push(_local);
            break;
          case op.LDGLOBAL:
            _global = this.globals[code[++pc]];
            if (typeof _global === 'undefined') {
              _name = this.codeObj.globalNames[code[pc]];
              throw new Error("" + _name + " is not defined");
            }
            stack.push(_global);
            break;
          case op.STLOCAL:
            localContext[code[++pc]] = stack[stack.length - 1];
            break;
          case op.STGLOBAL:
            this.globals[code[++pc]] = stack[stack.length - 1];
            break;
          case op.CALL:
            _func = this.codeObj.functions[code[++pc]];
            _args = (function() {
              var _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = _func.argc; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                _results.push(stack.pop());
              }
              return _results;
            })();
            if (_func instanceof BuiltinFunction) {
              stack.push(_func.invoke(_args));
            } else if (_func instanceof UserFunction) {
              _callee = this.codeObj.funcInfos[code[pc]].name;
              _func.invoke(((function(_this) {
                return function(code, args) {
                  var _i, _localContext, _ref;
                  _localContext = [];
                  for (i = _i = 0, _ref = _this.codeObj.localNames[_callee].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    _localContext.push(void 0);
                  }
                  [].splice.apply(_localContext, [0, _func.argc - 0].concat(args)), args;
                  return stack.push(_this._run(code, _localContext, _callee));
                };
              })(this)), _args);
            }
            break;
          case op.RET:
            return stack.pop();
          case op.JT:
            ++pc;
            if (stack.pop()) {
              pc = code[pc];
              continue;
            }
            break;
          case op.JF:
            ++pc;
            if (!stack.pop()) {
              pc = code[pc];
              continue;
            }
            break;
          case op.JMP:
            pc = code[++pc];
            continue;
          case op.ADD:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x + _y);
            break;
          case op.SUB:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x - _y);
            break;
          case op.MUL:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x * _y);
            break;
          case op.DIV:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x / _y);
            break;
          case op.MOD:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x % _y);
            break;
          case op.DELLOCAL:
            delete localContext[code[++pc]];
            break;
          case op.DELGLOBAL:
            delete this.globals[code[++pc]];
            stack.push(true);
            break;
          case op.INC:
            ++stack[stack.length - 1];
            break;
          case op.DEC:
            --stack[stack.length - 1];
            break;
          case op.POS:
            stack[stack.length - 1] = +stack[stack.length - 1];
            break;
          case op.NEG:
            stack[stack.length - 1] = -stack[stack.length - 1];
            break;
          case op.LSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x << _y);
            break;
          case op.URSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >>> _y);
            break;
          case op.RSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >> _y);
            break;
          case op.LTE:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x <= _y);
            break;
          case op.GTE:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >= _y);
            break;
          case op.LT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x < _y);
            break;
          case op.GT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x > _y);
            break;
          case op.EQ:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x === _y);
            break;
          case op.NEQ:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x !== _y);
            break;
          case op.NOT:
            stack[stack.length - 1] = !stack[stack.length - 1];
            break;
          case op.BNEG:
            stack[stack.length - 1] = ~stack[stack.length - 1];
            break;
          case op.BAND:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x & _y);
            break;
          case op.BXOR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x ^ _y);
            break;
          case op.BOR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x | _y);
            break;
          case op.AND:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x && _y);
            break;
          case op.OR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x || _y);
            break;
          case op.ROT:
            _x = stack.pop();
            _y = stack.pop();
            stack.push(_x);
            stack.push(_y);
            break;
          case op.DUP:
            stack.push(stack[stack.length - 1]);
            break;
          case op.TYPEOF:
            stack.push(typeof stack.pop);
            break;
          case op.NRET:
            return void 0;
          default:
            throw new Error("Invalid opcode " + code[pc]);
        }
        pc++;
      }
      return 0;
    };

    return LogoVM;

  })();

  this.LogoVM = LogoVM;

}).call(this);
