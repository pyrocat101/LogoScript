// Generated by CoffeeScript 1.3.1
(function() {
  var op, symTable, _genStore;

  op = require('./opcodes');

  symTable = require('./symTable');

  _genStore = function(codeObj) {
    switch (this.symInfo.flag) {
      case symTable.SYM_LOCAL:
        return codeObj.emit(op.STLOCAL, this.symInfo.number);
      case symTable.SYM_GLOBAL:
        return codeObj.emit(op.STGLOBAL, this.symInfo.number);
      default:
        throw new Error("Invalid symbol: " + this.name);
    }
  };

  this.getGenerator = function(codeObj) {
    var gen;
    gen = {
      genVariable: function() {
        switch (this.symInfo.flag) {
          case symTable.SYM_LOCAL:
            return codeObj.emit(op.LDLOCAL, this.symInfo.number);
          case symTable.SYM_GLOBAL:
            return codeObj.emit(op.LDGLOBAL, this.symInfo.number);
          default:
            throw new Error("Invalid symbol: " + this.name);
        }
      },
      genLiteral: function() {
        return codeObj.emit(op.LDCONST, this.constNum);
      },
      genFunctionCall: function() {
        var arg, _i, _len, _ref;
        _ref = this["arguments"].reverse();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          arg.genCode();
        }
        return codeObj.emit(op.CALL, this.symInfo.number);
      },
      genPostfixExpression: function() {
        this.expression.genCode();
        codeObj.emit(op.DUP);
        switch (this.operator) {
          case '++':
            codeObj.emit(op.INC);
            break;
          case '--':
            codeObj.emit(op.DEC);
        }
        _genStore.call(this.expression, codeObj);
        return codeObj.emit(op.POP);
      },
      genUnaryExpression: function() {
        this.expression.genCode();
        if (this.operator === 'delete' && (this.expression.symInfo != null)) {
          switch (this.symInfo.flag) {
            case symTable.SYM_LOCAL:
              return codeObj.emit(op.DELLOCAL, this.symInfo.number);
            case symTable.SYM_GLOBAL:
              return codeObj.emit(op.DELGLOBAL, this.symInfo.number);
            default:
              throw new Error("Invalid symbol: " + this.name);
          }
        } else {
          switch (this.operator) {
            case '++':
              return codeObj.emit(op.INC);
            case '--':
              return codeObj.emit(op.DEC);
            case '+':
              return codeObj.emit(op.POS);
            case '-':
              return codeObj.emit(op.NEG);
            case '~':
              return codeObj.emit(op.BNEG);
            case '!':
              return codeObj.emit(op.NOT);
            case 'typeof':
              return codeObj.emit(op.TYPEOF);
          }
        }
      },
      genBinaryExpression: function() {
        this.left.genCode();
        this.right.genCode();
        switch (this.operator) {
          case '*':
            return codeObj.emit(op.MUL);
          case '/':
            return codeObj.emit(op.DIV);
          case '%':
            return codeObj.emit(op.MOD);
          case '+':
            return codeObj.emit(op.ADD);
          case '-':
            return codeObj.emit(op.SUB);
          case '<<':
            return codeObj.emit(op.LSHIFT);
          case '>>>':
            return codeObj.emit(op.URSHIFT);
          case '>>':
            return codeObj.emit(op.RSHIFT);
          case '<=':
            return codeObj.emit(op.LTE);
          case '>=':
            return codeObj.emit(op.GTE);
          case '<':
            return codeObj.emit(op.LT);
          case '>':
            return codeObj.emit(op.GT);
          case '==':
            return codeObj.emit(op.EQ);
          case '!=':
            return codeObj.emit(op.NEQ);
          case '&':
            return codeObj.emit(op.BAND);
          case '^':
            return codeObj.emit(op.BXOR);
          case '|':
            return codeObj.emit(op.BOR);
          case '&&':
            return codeObj.emit(op.AND);
          case '||':
            return codeObj.emit(op.OR);
          case ',':
            return codeObj.emit(op.ROT, op.POP);
        }
      },
      genConditionalExpression: function() {
        var slot1, slot2;
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot1 = codeObj.reserveSlot();
        this.trueExpression.genCode();
        codeObj.emit(op.JMP);
        slot2 = codeObj.reserveSlot();
        codeObj.patchSlot(slot1, codeObj.peekLabel());
        this.falseExpression.genCode();
        return codeObj.patchSlot(slot2, codeObj.peekLabel());
      },
      genAssignmentExpression: function() {
        this.left.genCode();
        this.right.genCode();
        switch (this.operator) {
          case '*=':
            codeObj.emit(op.MUL);
            break;
          case '/=':
            codeObj.emit(op.DIV);
            break;
          case '%=':
            codeObj.emit(op.MOD);
            break;
          case '+=':
            codeObj.emit(op.ADD);
            break;
          case '-=':
            codeObj.emit(op.SUB);
            break;
          case '<<=':
            codeObj.emit(op.LSHIFT);
            break;
          case '>>=':
            codeObj.emit(op.RSHIFT);
            break;
          case '>>>=':
            codeObj.emit(op.URSHIFT);
            break;
          case '&=':
            codeObj.emit(op.BAND);
            break;
          case '^=':
            codeObj.emit(op.BXOR);
            break;
          case '|=':
            codeObj.emit(op.BOR);
        }
        return _genStore.call(this.left, codeObj);
      },
      genBlock: function() {
        var stmt, _i, _len, _ref, _results;
        _ref = this.statements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stmt = _ref[_i];
          stmt.genCode();
          if (stmt.leaveResult != null) {
            _results.push(codeObj.emit(op.POP));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      genVariableStatement: function() {
        var decl, _i, _len, _ref;
        _ref = this.declarations.splice(0, this.declarations.length - 1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          decl = _ref[_i];
          decl.genCode();
          codeObj.emit(op.POP);
        }
        return this.declarations[this.declarations.length - 1].genCode();
      },
      genVariableDeclaration: function() {
        this.value.genCode();
        switch (this.symInfo.flag) {
          case symTable.SYM_LOCAL:
            return codeObj.emit(op.STLOCAL, this.symInfo.number);
          case symTable.SYM_GLOBAL:
            return codeObj.emit(op.STGLOBAL, this.symInfo.number);
          default:
            throw new Error("Invalid symbol: " + this.name);
        }
      },
      genEmptyStatement: function() {},
      genIfStatement: function() {
        var slot1, slot2;
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot1 = codeObj.reserveSlot();
        this.ifStatement.genCode();
        if (this.ifStatement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        if (this.elseStatement != null) {
          codeObj.emit(op.JMP);
          slot2 = codeObj.reserveSlot();
        }
        codeObj.patchSlot(slot1, codeObj.peekLabel());
        if (this.elseStatement != null) {
          this.elseStatement.genCode();
          if (this.elseStatement.leaveResult != null) {
            codeObj.emit(op.POP);
          }
          return codeObj.patchSlot(slot2, codeObj.peekLabel());
        }
      },
      genDoWhileStatement: function() {
        var label1, label2, label3;
        codeObj.scopes.pushScope();
        label1 = codeObj.peekLabel();
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        label2 = codeObj.peekLabel();
        this.condition.genCode();
        codeObj.emit(op.JT, label1);
        label3 = codeObj.peekLabel();
        codeObj.scopes.patchContinue(label2);
        codeObj.scopes.patchBreak(label3);
        return codeObj.scopes.popScope();
      },
      genWhileStatement: function() {
        var label1, label2, slot2;
        codeObj.scopes.pushScope();
        label1 = codeObj.peekLabel();
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot2 = codeObj.reserveSlot();
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        codeObj.emit(op.JMP, label1);
        label2 = codeObj.peekLabel();
        codeObj.patchSlot(slot2, label2);
        codeObj.scopes.patchContinue(label1);
        codeObj.scopes.patchBreak(label2);
        return codeObj.scopes.popScope();
      },
      genForStatement: function() {
        var label1, label2, label3, slot3;
        codeObj.scopes.pushScope();
        if (this.initializer != null) {
          this.initializer.genCode();
          if (this.initializer.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        label1 = codeObj.peekLabel();
        if (this.test != null) {
          this.test.genCode();
          codeObj.emit(op.JF);
          slot3 = codeObj.reserveSlot();
        }
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        label2 = codeObj.peekLabel();
        if (this.counter != null) {
          this.counter.genCode();
          if (this.counter.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        codeObj.emit(op.JMP, label1);
        label3 = codeObj.peekLabel();
        if (this.test != null) {
          codeObj.patchSlot(slot3, label3);
        }
        codeObj.scopes.patchContinue(label2);
        codeObj.scopes.patchBreak(label3);
        return codeObj.scopes.popScope();
      },
      genContinueStatement: function() {
        codeObj.emit(op.JMP);
        return codeObj.scopes.addContinueSlot(codeObj.reserveSlot());
      },
      genBreakStatement: function() {
        codeObj.emit(op.JMP);
        return codeObj.scopes.addBreakSlot(codeObj.reserveSlot());
      },
      genReturnStatement: function() {
        if (this.value != null) {
          this.value.genCode();
          return codeObj.emit(op.RET);
        } else {
          return codeObj.emit(op.NRET);
        }
      },
      genFunction: function() {
        var elem, _i, _len, _ref;
        codeObj.startFuncCode(this.symInfo.number);
        _ref = this.elements;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          elem.genCode();
          if (elem.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        return codeObj.endFuncCode();
      },
      genProgram: function() {
        var elem, _i, _len, _ref, _results;
        _ref = this.elements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          elem.genCode();
          if (elem.leaveResult != null) {
            _results.push(codeObj.emit(op.POP));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    return gen;
  };

}).call(this);
