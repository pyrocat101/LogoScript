require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Canvas, Turtle, deg2rad, getMathFuncs, rad2deg;

  Canvas = require('./canvas');

  deg2rad = Math.PI / 180;

  rad2deg = 180 / Math.PI;

  getMathFuncs = function(cb) {
    cb('abs', Math.abs, 1);
    cb('acos', (function(x) {
      return rad2deg * Math.acos(x);
    }), 1);
    cb('asin', (function(x) {
      return rad2deg * Math.asin(x);
    }), 1);
    cb('atan', (function(x) {
      return rad2deg * Math.atan(x);
    }), 1);
    cb('atan2', (function(y, x) {
      return rad2deg * Math.atan2(y, x);
    }), 2);
    cb('ceil', Math.ceil, 1);
    cb('cos', (function(x) {
      return Math.cos(x * deg2rad);
    }), 1);
    cb('exp', Math.exp, 1);
    cb('floor', Math.floor, 1);
    cb('log', Math.log, 1);
    cb('max', Math.max, 2);
    cb('min', Math.min, 2);
    cb('pow', Math.pow, 2);
    cb('random', Math.random, 0);
    cb('round', Math.round, 1);
    cb('sin', (function(x) {
      return Math.sin(x * deg2rad);
    }), 1);
    cb('sqrt', Math.sqrt, 1);
    return cb('tan', (function(x) {
      return Math.tan(x * deg2rad);
    }), 1);
  };

  this.getMathFuncs = getMathFuncs;

  Turtle = (function() {
    function Turtle(options) {
      var height, width;
      this._canvas = Canvas();
      this._ctx = this._canvas.getContext('2d');
      this._ctx.save();
      width = this._canvas.width;
      height = this._canvas.height;
      this._ctx.fillStyle = 'white';
      this._ctx.fillRect(-width / 2, -height / 2, width, height);
      this._ctx.restore();
      this._ctx.moveTo(0, 0);
      this._ctx.lineJoin = this._ctx.lineCap = 'round';
      this._posx = 0;
      this._posy = 0;
      this._heading = 0;
      this._isPenUp = false;
    }

    Turtle.prototype.fd = function(step) {
      var x, y;
      x = this._posx + step * Math.sin(this._heading / 180 * Math.PI);
      y = this._posy + step * Math.cos(this._heading / 180 * Math.PI);
      return this.setxy(x, y);
    };

    Turtle.prototype.bk = function(step) {
      var x, y;
      x = this._posx - step * Math.sin(this._heading / 180 * Math.PI);
      y = this._posy - step * Math.cos(this._heading / 180 * Math.PI);
      return this.setxy(x, y);
    };

    Turtle.prototype.lt = function(angle) {
      return this._heading -= angle;
    };

    Turtle.prototype.rt = function(angle) {
      return this._heading += angle;
    };

    Turtle.prototype.pu = function() {
      return this._isPenUp = true;
    };

    Turtle.prototype.pd = function() {
      return this._isPenUp = false;
    };

    Turtle.prototype.home = function() {
      this.setxy(0, 0);
      return this.seth(0);
    };

    Turtle.prototype.setx = function(x) {
      return this.setxy(x, this._posy);
    };

    Turtle.prototype.sety = function(y) {
      return this.setxy(this._posx, y);
    };

    Turtle.prototype.seth = function(angle) {
      return this._heading = angle;
    };

    Turtle.prototype.seth2 = function(x, y) {
      var dx, dy;
      dx = x - this._posx;
      dy = y - this._posy;
      return this._heading = 90 + rad2deg * Math.atan(dy, dx);
    };

    Turtle.prototype.geth = function() {
      return this._heading % 180;
    };

    Turtle.prototype.clear = function(c) {
      var h, w;
      w = this._canvas.width;
      h = this._canvas.height;
      this._ctx.save();
      this._ctx.fillStyle = c;
      this._ctx.fillRect(-(w / 2), -(h / 2), w, h);
      return this._ctx.restore();
    };

    Turtle.prototype.setxy = function(x, y) {
      if (!this._isPenUp) {
        this._ctx.beginPath();
        this._ctx.moveTo(this._posx, this._posy);
        this._ctx.lineTo(x, y);
        this._ctx.stroke();
      }
      this._posx = x;
      return this._posy = y;
    };

    Turtle.prototype.setpc = function(c) {
      this._ctx.strokeStyle = c;
      return this._ctx.fillStyle = c;
    };

    Turtle.prototype.setpw = function(w) {
      return this._ctx.lineWidth = w;
    };

    Turtle.prototype.text = function(t) {
      this._ctx.save();
      this._ctx.transform(1, 0, 0, -1, 0, 0);
      this._ctx.fillText(t, this._posx, this._posy);
      return this._ctx.restore();
    };

    Turtle.prototype.font = function(f) {
      return this._ctx.font = f;
    };

    Turtle.prototype.getFuncs = function(cb) {
      cb('fd', this.fd.bind(this), 1);
      cb('bk', this.bk.bind(this), 1);
      cb('lt', this.lt.bind(this), 1);
      cb('rt', this.rt.bind(this), 1);
      cb('pu', this.pu.bind(this), 0);
      cb('pd', this.pd.bind(this), 0);
      cb('home', this.home.bind(this), 0);
      cb('setx', this.setx.bind(this), 1);
      cb('sety', this.sety.bind(this), 1);
      cb('seth', this.seth.bind(this), 1);
      cb('seth2', this.seth2.bind(this), 2);
      cb('geth', this.geth.bind(this), 0);
      cb('setxy', this.setxy.bind(this), 2);
      cb('setpc', this.setpc.bind(this), 1);
      cb('setpw', this.setpw.bind(this), 1);
      return cb('clear', this.clear.bind(this), 1);
    };

    return Turtle;

  })();

  this.Turtle = Turtle;

}).call(this);

},{"./canvas":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function() {
    var canvas, canvasBox, ctx;
    canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 400;
    canvasBox = document.getElementById('canvas-box');
    canvasBox.innerHTML = "";
    canvasBox.appendChild(canvas);
    ctx = canvas.getContext('2d');
    ctx.setTransform(1, 0, 0, -1, canvas.width / 2, canvas.height / 2);
    return canvas;
  };

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var op, symTable, _genStore;

  op = require('./opcodes');

  symTable = require('./symTable');

  _genStore = function(codeObj) {
    switch (this.symInfo.flag) {
      case symTable.SYM_LOCAL:
        return codeObj.emit(op.STLOCAL, this.symInfo.number);
      case symTable.SYM_GLOBAL:
        return codeObj.emit(op.STGLOBAL, this.symInfo.number);
      default:
        throw new Error("Invalid symbol: " + this.name);
    }
  };

  this.getGenerator = function(codeObj) {
    var gen;
    gen = {
      genVariable: function() {
        switch (this.symInfo.flag) {
          case symTable.SYM_LOCAL:
            return codeObj.emit(op.LDLOCAL, this.symInfo.number);
          case symTable.SYM_GLOBAL:
            return codeObj.emit(op.LDGLOBAL, this.symInfo.number);
          default:
            throw new Error("Invalid symbol: " + this.name);
        }
      },
      genLiteral: function() {
        return codeObj.emit(op.LDCONST, this.constNum);
      },
      genFunctionCall: function() {
        var arg, _i, _len, _ref;
        _ref = this["arguments"].reverse();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          arg.genCode();
        }
        return codeObj.emit(op.CALL, this.symInfo.number);
      },
      genPostfixExpression: function() {
        this.expression.genCode();
        codeObj.emit(op.DUP);
        switch (this.operator) {
          case '++':
            codeObj.emit(op.INC);
            break;
          case '--':
            codeObj.emit(op.DEC);
        }
        _genStore.call(this.expression, codeObj);
        return codeObj.emit(op.POP);
      },
      genUnaryExpression: function() {
        this.expression.genCode();
        if (this.operator === 'delete' && (this.expression.symInfo != null)) {
          switch (this.symInfo.flag) {
            case symTable.SYM_LOCAL:
              return codeObj.emit(op.DELLOCAL, this.symInfo.number);
            case symTable.SYM_GLOBAL:
              return codeObj.emit(op.DELGLOBAL, this.symInfo.number);
            default:
              throw new Error("Invalid symbol: " + this.name);
          }
        } else {
          switch (this.operator) {
            case '++':
              return codeObj.emit(op.INC);
            case '--':
              return codeObj.emit(op.DEC);
            case '+':
              return codeObj.emit(op.POS);
            case '-':
              return codeObj.emit(op.NEG);
            case '~':
              return codeObj.emit(op.BNEG);
            case '!':
              return codeObj.emit(op.NOT);
            case 'typeof':
              return codeObj.emit(op.TYPEOF);
          }
        }
      },
      genBinaryExpression: function() {
        this.left.genCode();
        this.right.genCode();
        switch (this.operator) {
          case '*':
            return codeObj.emit(op.MUL);
          case '/':
            return codeObj.emit(op.DIV);
          case '%':
            return codeObj.emit(op.MOD);
          case '+':
            return codeObj.emit(op.ADD);
          case '-':
            return codeObj.emit(op.SUB);
          case '<<':
            return codeObj.emit(op.LSHIFT);
          case '>>>':
            return codeObj.emit(op.URSHIFT);
          case '>>':
            return codeObj.emit(op.RSHIFT);
          case '<=':
            return codeObj.emit(op.LTE);
          case '>=':
            return codeObj.emit(op.GTE);
          case '<':
            return codeObj.emit(op.LT);
          case '>':
            return codeObj.emit(op.GT);
          case '==':
            return codeObj.emit(op.EQ);
          case '!=':
            return codeObj.emit(op.NEQ);
          case '&':
            return codeObj.emit(op.BAND);
          case '^':
            return codeObj.emit(op.BXOR);
          case '|':
            return codeObj.emit(op.BOR);
          case '&&':
            return codeObj.emit(op.AND);
          case '||':
            return codeObj.emit(op.OR);
          case ',':
            return codeObj.emit(op.ROT, op.POP);
        }
      },
      genConditionalExpression: function() {
        var slot1, slot2;
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot1 = codeObj.reserveSlot();
        this.trueExpression.genCode();
        codeObj.emit(op.JMP);
        slot2 = codeObj.reserveSlot();
        codeObj.patchSlot(slot1, codeObj.peekLabel());
        this.falseExpression.genCode();
        return codeObj.patchSlot(slot2, codeObj.peekLabel());
      },
      genAssignmentExpression: function() {
        this.left.genCode();
        this.right.genCode();
        switch (this.operator) {
          case '*=':
            codeObj.emit(op.MUL);
            break;
          case '/=':
            codeObj.emit(op.DIV);
            break;
          case '%=':
            codeObj.emit(op.MOD);
            break;
          case '+=':
            codeObj.emit(op.ADD);
            break;
          case '-=':
            codeObj.emit(op.SUB);
            break;
          case '<<=':
            codeObj.emit(op.LSHIFT);
            break;
          case '>>=':
            codeObj.emit(op.RSHIFT);
            break;
          case '>>>=':
            codeObj.emit(op.URSHIFT);
            break;
          case '&=':
            codeObj.emit(op.BAND);
            break;
          case '^=':
            codeObj.emit(op.BXOR);
            break;
          case '|=':
            codeObj.emit(op.BOR);
        }
        return _genStore.call(this.left, codeObj);
      },
      genBlock: function() {
        var stmt, _i, _len, _ref, _results;
        _ref = this.statements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stmt = _ref[_i];
          stmt.genCode();
          if (stmt.leaveResult != null) {
            _results.push(codeObj.emit(op.POP));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      genVariableStatement: function() {
        var decl, _i, _len, _ref;
        _ref = this.declarations.splice(0, this.declarations.length - 1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          decl = _ref[_i];
          decl.genCode();
          codeObj.emit(op.POP);
        }
        return this.declarations[this.declarations.length - 1].genCode();
      },
      genVariableDeclaration: function() {
        this.value.genCode();
        switch (this.symInfo.flag) {
          case symTable.SYM_LOCAL:
            return codeObj.emit(op.STLOCAL, this.symInfo.number);
          case symTable.SYM_GLOBAL:
            return codeObj.emit(op.STGLOBAL, this.symInfo.number);
          default:
            throw new Error("Invalid symbol: " + this.name);
        }
      },
      genEmptyStatement: function() {},
      genIfStatement: function() {
        var slot1, slot2;
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot1 = codeObj.reserveSlot();
        this.ifStatement.genCode();
        if (this.ifStatement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        if (this.elseStatement != null) {
          codeObj.emit(op.JMP);
          slot2 = codeObj.reserveSlot();
        }
        codeObj.patchSlot(slot1, codeObj.peekLabel());
        if (this.elseStatement != null) {
          this.elseStatement.genCode();
          if (this.elseStatement.leaveResult != null) {
            codeObj.emit(op.POP);
          }
          return codeObj.patchSlot(slot2, codeObj.peekLabel());
        }
      },
      genDoWhileStatement: function() {
        var label1, label2, label3;
        codeObj.scopes.pushScope();
        label1 = codeObj.peekLabel();
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        label2 = codeObj.peekLabel();
        this.condition.genCode();
        codeObj.emit(op.JT, label1);
        label3 = codeObj.peekLabel();
        codeObj.scopes.patchContinue(label2);
        codeObj.scopes.patchBreak(label3);
        return codeObj.scopes.popScope();
      },
      genWhileStatement: function() {
        var label1, label2, slot2;
        codeObj.scopes.pushScope();
        label1 = codeObj.peekLabel();
        this.condition.genCode();
        codeObj.emit(op.JF);
        slot2 = codeObj.reserveSlot();
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        codeObj.emit(op.JMP, label1);
        label2 = codeObj.peekLabel();
        codeObj.patchSlot(slot2, label2);
        codeObj.scopes.patchContinue(label1);
        codeObj.scopes.patchBreak(label2);
        return codeObj.scopes.popScope();
      },
      genForStatement: function() {
        var label1, label2, label3, slot3;
        codeObj.scopes.pushScope();
        if (this.initializer != null) {
          this.initializer.genCode();
          if (this.initializer.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        label1 = codeObj.peekLabel();
        if (this.test != null) {
          this.test.genCode();
          codeObj.emit(op.JF);
          slot3 = codeObj.reserveSlot();
        }
        this.statement.genCode();
        if (this.statement.leaveResult != null) {
          codeObj.emit(op.POP);
        }
        label2 = codeObj.peekLabel();
        if (this.counter != null) {
          this.counter.genCode();
          if (this.counter.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        codeObj.emit(op.JMP, label1);
        label3 = codeObj.peekLabel();
        if (this.test != null) {
          codeObj.patchSlot(slot3, label3);
        }
        codeObj.scopes.patchContinue(label2);
        codeObj.scopes.patchBreak(label3);
        return codeObj.scopes.popScope();
      },
      genContinueStatement: function() {
        codeObj.emit(op.JMP);
        return codeObj.scopes.addContinueSlot(codeObj.reserveSlot());
      },
      genBreakStatement: function() {
        codeObj.emit(op.JMP);
        return codeObj.scopes.addBreakSlot(codeObj.reserveSlot());
      },
      genReturnStatement: function() {
        if (this.value != null) {
          this.value.genCode();
          return codeObj.emit(op.RET);
        } else {
          return codeObj.emit(op.NRET);
        }
      },
      genFunction: function() {
        var elem, _i, _len, _ref;
        codeObj.startFuncCode(this.symInfo.number);
        _ref = this.elements;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          elem.genCode();
          if (elem.leaveResult != null) {
            codeObj.emit(op.POP);
          }
        }
        return codeObj.endFuncCode();
      },
      genProgram: function() {
        var elem, _i, _len, _ref, _results;
        _ref = this.elements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          elem.genCode();
          if (elem.leaveResult != null) {
            _results.push(codeObj.emit(op.POP));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    return gen;
  };

}).call(this);

},{"./opcodes":8,"./symTable":10}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var BuiltinFunction, LogoFunction, Scope, ScopeChain, UserFunction, op, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  op = require('./opcodes');

  utils = require('./utils');

  Scope = (function() {
    function Scope() {
      this.continueSlots = [];
      this.breakSlots = [];
    }

    return Scope;

  })();

  ScopeChain = (function() {
    function ScopeChain(codeObj) {
      this.codeObj = codeObj;
      this._chain = [];
    }

    ScopeChain.prototype.pushScope = function() {
      return this._chain.push(new Scope);
    };

    ScopeChain.prototype.popScope = function() {
      return this._chain.pop();
    };

    ScopeChain.prototype.patchContinue = function(label) {
      var top;
      if (this._chain.length < 1) {
        throw new Error('No scope in chain');
      }
      top = this._chain[this._chain.length - 1];
      return top.continueSlots.forEach((function(_this) {
        return function(slot) {
          return _this.codeObj._currentCode[slot] = label;
        };
      })(this));
    };

    ScopeChain.prototype.patchBreak = function(label) {
      var top;
      if (this._chain.length < 1) {
        throw new Error('No scope in chain');
      }
      top = this._chain[this._chain.length - 1];
      return top.breakSlots.forEach((function(_this) {
        return function(slot) {
          return _this.codeObj._currentCode[slot] = label;
        };
      })(this));
    };

    ScopeChain.prototype.addBreakSlot = function(slot) {
      var top;
      top = this._chain[this._chain.length - 1];
      return top.breakSlots.push(slot);
    };

    ScopeChain.prototype.addContinueSlot = function(slot) {
      var top;
      top = this._chain[this._chain.length - 1];
      return top.continueSlots.push(slot);
    };

    return ScopeChain;

  })();

  LogoFunction = (function() {
    function LogoFunction(name, argc) {
      this.name = name;
      this.argc = argc;
    }

    LogoFunction.prototype.invoke = function(args) {
      if (args.length !== this.argc) {
        throw new Error("" + name + "() takes exactly " + this.argc + " arguments (" + argc.length + " given)");
      }
    };

    return LogoFunction;

  })();

  BuiltinFunction = (function(_super) {
    __extends(BuiltinFunction, _super);

    function BuiltinFunction(name, argc, func) {
      this.func = func;
      BuiltinFunction.__super__.constructor.call(this, name, argc);
    }

    BuiltinFunction.prototype.invoke = function(args) {
      BuiltinFunction.__super__.invoke.call(this, args);
      return this.func.apply(null, args);
    };

    return BuiltinFunction;

  })(LogoFunction);

  UserFunction = (function(_super) {
    __extends(UserFunction, _super);

    function UserFunction(name, argc) {
      UserFunction.__super__.constructor.call(this, name, argc);
      this.code = [];
    }

    UserFunction.prototype.invoke = function(visitor, args) {
      UserFunction.__super__.invoke.call(this, args);
      return visitor(this.code, args);
    };

    return UserFunction;

  })(LogoFunction);

  this.BuiltinFunction = BuiltinFunction;

  this.UserFunction = UserFunction;

  this.CodeObject = (function() {
    function CodeObject(consts, globals, funcs, locals) {
      this.scopes = new ScopeChain(this);
      this.code = [];
      this._currentCode = this.code;
      this.consts = this._initConsts(consts);
      this.globalNames = this._initGlobalNames(globals);
      this.funcInfos = this._initFuncInfos(funcs);
      this.functions = [];
      this.localNames = this._initLocalNames(locals);
    }

    CodeObject.prototype.startFuncCode = function(funcNum) {
      var func;
      func = this.funcInfos[funcNum];
      this.functions[funcNum] = new UserFunction(func.name, func.argc);
      return this._currentCode = this.functions[funcNum].code;
    };

    CodeObject.prototype.endFuncCode = function(funcNum) {
      return this._currentCode = this.code;
    };

    CodeObject.prototype.addBuiltinFuncs = function(builtins) {
      return ([].splice.apply(this.functions, [0, builtins.length - 0].concat(builtins)), builtins);
    };

    CodeObject.prototype._initConsts = function(consts) {
      var x, _array, _i, _len, _results;
      _array = [];
      consts.forEach(function(obj, nr) {
        return _array.push([obj, nr]);
      });
      _array.sort(function(x, y) {
        return x[1] - y[1];
      });
      _results = [];
      for (_i = 0, _len = _array.length; _i < _len; _i++) {
        x = _array[_i];
        _results.push(x[0]);
      }
      return _results;
    };

    CodeObject.prototype._initGlobalNames = function(globals) {
      var x, _array, _i, _len, _results;
      _array = [];
      globals.forEach(function(name, ste) {
        return _array.push([name, ste.number]);
      });
      _array.sort(function(x, y) {
        return x[1] - y[1];
      });
      _results = [];
      for (_i = 0, _len = _array.length; _i < _len; _i++) {
        x = _array[_i];
        _results.push(x[0]);
      }
      return _results;
    };

    CodeObject.prototype._initFuncInfos = function(funcs) {
      var x, _array, _i, _len, _results;
      _array = [];
      funcs.forEach(function(name, fe) {
        return _array.push([fe.number, fe.argc, name]);
      });
      _array.sort(function(x, y) {
        return x[0] - y[0];
      });
      _results = [];
      for (_i = 0, _len = _array.length; _i < _len; _i++) {
        x = _array[_i];
        _results.push({
          name: x[2],
          argc: x[1]
        });
      }
      return _results;
    };

    CodeObject.prototype._initLocalNames = function(locals) {
      var k, v, x, _array, _localNames;
      _localNames = {};
      for (k in locals) {
        if (!__hasProp.call(locals, k)) continue;
        v = locals[k];
        _array = [];
        v.forEach(function(name, ste) {
          return _array.push([name, ste.number]);
        });
        _array.sort(function(x, y) {
          return x[1] - y[1];
        });
        _localNames[k] = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = _array.length; _i < _len; _i++) {
            x = _array[_i];
            _results.push(x[0]);
          }
          return _results;
        })();
      }
      return _localNames;
    };

    CodeObject.prototype.emit = function() {
      var bytecode, x, _i, _len, _results;
      bytecode = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = bytecode.length; _i < _len; _i++) {
        x = bytecode[_i];
        _results.push(this._currentCode.push(x));
      }
      return _results;
    };

    CodeObject.prototype._getOpName = function(opcode) {
      var name, num;
      for (name in op) {
        num = op[name];
        if (opcode === num) {
          return name;
        }
      }
    };

    CodeObject.prototype.dump = function() {
      var i, _funcName, _i, _ref, _results;
      this._dumpCode(this.code);
      _results = [];
      for (i = _i = 0, _ref = this.functions.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.functions[i] instanceof UserFunction) {
          _funcName = this.functions[i].name;
          utils.printf('%s:', _funcName);
          _results.push(this._dumpCode(this.functions[i].code, this.localNames[_funcName]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CodeObject.prototype._dumpCode = function(code, localNames) {
      var i, len, opname, _const, _funcName, _globalName, _local, _results;
      if (localNames == null) {
        localNames = this.globalNames;
      }
      i = 0;
      len = code.length;
      _results = [];
      while (i < len) {
        opname = this._getOpName(code[i]);
        utils.printf('%-4d%-10s', i, opname);
        switch (opname) {
          case 'LDCONST':
            _const = this.consts[code[++i]];
            if (_const.constructor === String) {
              utils.printf("%d ('%s')", code[i], _const);
            } else {
              utils.printf("%d (%s)", code[i], _const);
            }
            break;
          case 'LDLOCAL':
          case 'STLOCAL':
          case 'DELLOCAL':
            if (localNames == null) {
              throw new Error("Invalid local var");
            }
            _local = localNames[code[++i]];
            utils.printf('%d (%s)', code[i], _local);
            break;
          case 'LDGLOBAL':
          case 'STGLOBAL':
          case 'DELGLOBAL':
            _globalName = this.globalNames[code[++i]];
            utils.printf('%d (%s)', code[i], _globalName);
            break;
          case 'CALL':
            _funcName = this.funcInfos[code[++i]].name;
            utils.printf('%d (%s)', code[i], _funcName);
            break;
          case 'JT':
          case 'JF':
          case 'JMP':
            utils.printf('%d', code[++i]);
        }
        _results.push(i++);
      }
      return _results;
    };

    CodeObject.prototype.reserveSlot = function() {
      this.emit(0);
      return this._currentCode.length - 1;
    };

    CodeObject.prototype.genSlot = function() {
      return this._currentCode.length - 1;
    };

    CodeObject.prototype.patchSlot = function(slot, label) {
      return this._currentCode[slot] = label;
    };

    CodeObject.prototype.genLabel = function() {
      return this.genSlot();
    };

    CodeObject.prototype.peekLabel = function() {
      return this.genSlot() + 1;
    };

    return CodeObject;

  })();

}).call(this);

},{"./opcodes":8,"./utils":12}],"logo-script":[function(require,module,exports){
module.exports=require('r/TozS');
},{}],"r/TozS":[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var builtinFuncs, builtins, codeGen, codeObject, logoVM, parser, print, registerBuiltins, symTab, tree;

  parser = require('./parser');

  tree = require('./tree');

  codeObject = require('./codeObj');

  codeGen = require('./codeGen');

  symTab = require('./symTable');

  logoVM = require('./vm');

  builtins = require('./builtins');

  this.VERSION = '0.1.0';

  registerBuiltins = function(funcTable, builtins) {
    var builtin, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = builtins.length; _i < _len; _i++) {
      builtin = builtins[_i];
      _results.push(funcTable.add(builtin.name, builtin.argc));
    }
    return _results;
  };

  builtinFuncs = [];

  print = new codeObject.BuiltinFunction('print', 1, console.log);

  builtinFuncs.push(print);

  builtins.getMathFuncs(function(name, func, argc) {
    var f;
    f = new codeObject.BuiltinFunction(name, argc, func);
    return builtinFuncs.push(f);
  });

  this.run = function(src, options) {
    var codeGenerator, codeObj, parseTree, tabSet, turtle, turtleOpt, vm;
    if (options == null) {
      options = {};
    }
    parseTree = parser.parse(src);
    tabSet = new symTab.SymTabSet();
    turtleOpt = {
      width: options.width,
      height: options.height,
      output: options.output,
      antialias: options.antialias
    };
    turtle = new builtins.Turtle(turtleOpt);
    turtle.getFuncs(function(name, func, argc) {
      var f;
      f = new codeObject.BuiltinFunction(name, argc, func);
      return builtinFuncs.push(f);
    });
    registerBuiltins(tabSet.funcs, builtinFuncs);
    parseTree.accept(new tree.FirstPassVisitor(tabSet));
    if (options.ast) {
      console.log(require('util').inspect(parseTree, false, null));
    }
    codeObj = new codeObject.CodeObject(tabSet.consts, tabSet.globals, tabSet.funcs, tabSet.locals);
    codeGenerator = codeGen.getGenerator(codeObj);
    parseTree.accept(new tree.SecondPassVisitor(codeGenerator));
    codeObj.addBuiltinFuncs(builtinFuncs);
    parseTree.genCode();
    if (options.dump) {
      codeObj.dump();
    }
    vm = new logoVM.LogoVM(codeObj);
    return vm.run();
  };

}).call(this);

},{"./builtins":1,"./codeGen":3,"./codeObj":4,"./parser":9,"./symTable":10,"./tree":11,"./vm":13,"util":17}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Mixins, leaveResult, _binExpression,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixins = require('./utils').Mixins;

  leaveResult = {
    leaveResult: true
  };

  this.NumericLiteral = (function(_super) {
    __extends(NumericLiteral, _super);

    NumericLiteral.include(leaveResult);

    function NumericLiteral(value) {
      this.value = value;
    }

    NumericLiteral.prototype.accept = function(visitor) {
      return visitor.visitNumericLiteral(this);
    };

    return NumericLiteral;

  })(Mixins);

  this.StringLiteral = (function(_super) {
    __extends(StringLiteral, _super);

    StringLiteral.include(leaveResult);

    function StringLiteral(value) {
      this.value = value;
    }

    StringLiteral.prototype.accept = function(visitor) {
      return visitor.visitStringLiteral(this);
    };

    return StringLiteral;

  })(Mixins);

  this.NullLiteral = (function(_super) {
    __extends(NullLiteral, _super);

    function NullLiteral() {
      return NullLiteral.__super__.constructor.apply(this, arguments);
    }

    NullLiteral.include(leaveResult);

    NullLiteral.prototype.accept = function(visitor) {
      return visitor.visitNullLiteral(this);
    };

    return NullLiteral;

  })(Mixins);

  this.BooleanLiteral = (function(_super) {
    __extends(BooleanLiteral, _super);

    BooleanLiteral.include(leaveResult);

    function BooleanLiteral(value) {
      this.value = value;
    }

    BooleanLiteral.prototype.accept = function(visitor) {
      return visitor.visitBooleanLiteral(this);
    };

    return BooleanLiteral;

  })(Mixins);

  this.Variable = (function(_super) {
    __extends(Variable, _super);

    Variable.include(leaveResult);

    function Variable(name) {
      this.name = name;
    }

    Variable.prototype.accept = function(visitor) {
      return visitor.visitVariable(this);
    };

    return Variable;

  })(Mixins);

  this.FunctionCall = (function(_super) {
    __extends(FunctionCall, _super);

    FunctionCall.include(leaveResult);

    function FunctionCall(name, args) {
      this.name = name;
      this["arguments"] = args;
    }

    FunctionCall.prototype.accept = function(visitor) {
      var arg, _i, _len, _ref;
      _ref = this["arguments"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        arg.accept(visitor);
      }
      return visitor.visitFunctionCall(this);
    };

    return FunctionCall;

  })(Mixins);

  this.PostfixExpression = (function(_super) {
    __extends(PostfixExpression, _super);

    PostfixExpression.include(leaveResult);

    function PostfixExpression(operator, expression) {
      this.operator = operator;
      this.expression = expression;
    }

    PostfixExpression.prototype.accept = function(visitor) {
      this.expression.accept(visitor);
      return visitor.visitPostfixExpression(this);
    };

    return PostfixExpression;

  })(Mixins);

  this.UnaryExpression = (function(_super) {
    __extends(UnaryExpression, _super);

    UnaryExpression.include(leaveResult);

    function UnaryExpression(operator, expression) {
      this.operator = operator;
      this.expression = expression;
    }

    UnaryExpression.prototype.accept = function(visitor) {
      this.expression.accept(visitor);
      return visitor.visitUnaryExpression(this);
    };

    return UnaryExpression;

  })(Mixins);

  _binExpression = function(ctx, op, l, r) {
    ctx.operator = op;
    ctx.left = l;
    ctx.right = r;
  };

  this.BinaryExpression = (function(_super) {
    __extends(BinaryExpression, _super);

    BinaryExpression.include(leaveResult);

    function BinaryExpression(op, l, r) {
      _binExpression(this, op, l, r);
    }

    BinaryExpression.prototype.accept = function(visitor) {
      this.left.accept(visitor);
      this.right.accept(visitor);
      return visitor.visitBinaryExpression(this);
    };

    return BinaryExpression;

  })(Mixins);

  this.ConditionalExpression = (function(_super) {
    __extends(ConditionalExpression, _super);

    ConditionalExpression.include(leaveResult);

    function ConditionalExpression(condition, trueExpression, falseExpression) {
      this.condition = condition;
      this.trueExpression = trueExpression;
      this.falseExpression = falseExpression;
    }

    ConditionalExpression.prototype.accept = function(visitor) {
      this.condition.accept(visitor);
      this.trueExpression.accept(visitor);
      this.falseExpression.accept(visitor);
      return visitor.visitConditionalExpression(this);
    };

    return ConditionalExpression;

  })(Mixins);

  this.AssignmentExpression = (function(_super) {
    __extends(AssignmentExpression, _super);

    AssignmentExpression.include(leaveResult);

    function AssignmentExpression(op, l, r) {
      _binExpression(this, op, l, r);
    }

    AssignmentExpression.prototype.accept = function(visitor) {
      this.left.accept(visitor);
      this.right.accept(visitor);
      return visitor.visitAssignmentExpression(this);
    };

    return AssignmentExpression;

  })(Mixins);

  this.Block = (function(_super) {
    __extends(Block, _super);

    function Block(statements) {
      this.statements = statements;
    }

    Block.prototype.accept = function(visitor) {
      var stmt, _i, _len, _ref;
      _ref = this.statements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stmt = _ref[_i];
        stmt.accept(visitor);
      }
      return visitor.visitBlock(this);
    };

    return Block;

  })(Mixins);

  this.VariableStatement = (function(_super) {
    __extends(VariableStatement, _super);

    VariableStatement.include(leaveResult);

    function VariableStatement(declarations) {
      this.declarations = declarations;
    }

    VariableStatement.prototype.accept = function(visitor) {
      var decl, _i, _len, _ref;
      _ref = this.declarations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        decl = _ref[_i];
        decl.accept(visitor);
      }
      return visitor.visitVariableStatement(this);
    };

    return VariableStatement;

  })(Mixins);

  this.VariableDeclaration = (function(_super) {
    __extends(VariableDeclaration, _super);

    VariableDeclaration.include(leaveResult);

    function VariableDeclaration(name, value) {
      this.name = name;
      this.value = value;
    }

    VariableDeclaration.prototype.accept = function(visitor) {
      this.value.accept(visitor);
      return visitor.visitVariableDeclaration(this);
    };

    return VariableDeclaration;

  })(Mixins);

  this.EmptyStatement = (function(_super) {
    __extends(EmptyStatement, _super);

    function EmptyStatement() {
      return EmptyStatement.__super__.constructor.apply(this, arguments);
    }

    EmptyStatement.prototype.accept = function(visitor) {
      return visitor.visitEmptyStatement(this);
    };

    return EmptyStatement;

  })(Mixins);

  this.IfStatement = (function(_super) {
    __extends(IfStatement, _super);

    function IfStatement(condition, ifStatement, elseStatement) {
      this.condition = condition;
      this.ifStatement = ifStatement;
      this.elseStatement = elseStatement;
    }

    IfStatement.prototype.accept = function(visitor) {
      var _ref;
      this.condition.accept(visitor);
      this.ifStatement.accept(visitor);
      if ((_ref = this.elseStatement) != null) {
        _ref.accept(visitor);
      }
      return visitor.visitIfStatement(this);
    };

    return IfStatement;

  })(Mixins);

  this.DoWhileStatement = (function(_super) {
    __extends(DoWhileStatement, _super);

    function DoWhileStatement(condition, statement) {
      this.condition = condition;
      this.statement = statement;
    }

    DoWhileStatement.prototype.accept = function(visitor) {
      this.condition.accept(visitor);
      this.statement.accept(visitor);
      return visitor.visitDoWhileStatement(this);
    };

    return DoWhileStatement;

  })(Mixins);

  this.WhileStatement = (function(_super) {
    __extends(WhileStatement, _super);

    function WhileStatement(condition, statement) {
      this.condition = condition;
      this.statement = statement;
    }

    WhileStatement.prototype.accept = function(visitor) {
      this.condition.accept(visitor);
      this.statement.accept(visitor);
      return visitor.visitWhileStatement(this);
    };

    return WhileStatement;

  })(Mixins);

  this.ForStatement = (function(_super) {
    __extends(ForStatement, _super);

    function ForStatement(initializer, test, counter, statement) {
      this.initializer = initializer;
      this.test = test;
      this.counter = counter;
      this.statement = statement;
    }

    ForStatement.prototype.accept = function(visitor) {
      var _ref, _ref1, _ref2;
      if ((_ref = this.initializer) != null) {
        _ref.accept(visitor);
      }
      if ((_ref1 = this.test) != null) {
        _ref1.accept(visitor);
      }
      if ((_ref2 = this.counter) != null) {
        _ref2.accept(visitor);
      }
      this.statement.accept(visitor);
      return visitor.visitForStatement(this);
    };

    return ForStatement;

  })(Mixins);

  this.ContinueStatement = (function(_super) {
    __extends(ContinueStatement, _super);

    function ContinueStatement() {
      return ContinueStatement.__super__.constructor.apply(this, arguments);
    }

    ContinueStatement.prototype.accept = function(visitor) {
      return visitor.visitContinueStatement(this);
    };

    return ContinueStatement;

  })(Mixins);

  this.BreakStatement = (function(_super) {
    __extends(BreakStatement, _super);

    function BreakStatement() {
      return BreakStatement.__super__.constructor.apply(this, arguments);
    }

    BreakStatement.prototype.accept = function(visitor) {
      return visitor.visitBreakStatement(this);
    };

    return BreakStatement;

  })(Mixins);

  this.ReturnStatement = (function(_super) {
    __extends(ReturnStatement, _super);

    function ReturnStatement(value) {
      this.value = value;
    }

    ReturnStatement.prototype.accept = function(visitor) {
      var _ref;
      if ((_ref = this.value) != null) {
        _ref.accept(visitor);
      }
      return visitor.visitReturnStatement(this);
    };

    return ReturnStatement;

  })(Mixins);

  this.Function_ = (function(_super) {
    __extends(Function_, _super);

    function Function_(name, params, elements) {
      this.name = name;
      this.params = params;
      this.elements = elements;
    }

    Function_.prototype.accept = function(visitor) {
      var elem, _i, _len, _ref;
      visitor.enter('Function_', this);
      visitor.visitParameters(this.params);
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        elem.accept(visitor);
      }
      return visitor.visitFunction_(this);
    };

    return Function_;

  })(Mixins);

  this.Program = (function(_super) {
    __extends(Program, _super);

    function Program(elements) {
      this.elements = elements;
    }

    Program.prototype.accept = function(visitor) {
      var elem, _i, _len, _ref;
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        elem.accept(visitor);
      }
      return visitor.visitProgram(this);
    };

    return Program;

  })(Mixins);

}).call(this);

},{"./utils":12}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  this.HALT = 1;

  this.POP = 2;

  this.LDCONST = 3;

  this.LDLOCAL = 4;

  this.LDGLOBAL = 5;

  this.STLOCAL = 6;

  this.STGLOBAL = 7;

  this.CALL = 8;

  this.RET = 9;

  this.JT = 10;

  this.JF = 11;

  this.JMP = 12;

  this.ADD = 13;

  this.SUB = 14;

  this.MUL = 15;

  this.DIV = 16;

  this.MOD = 17;

  this.DELLOCAL = 18;

  this.DELGLOBAL = 19;

  this.INC = 20;

  this.DEC = 21;

  this.POS = 22;

  this.NEG = 23;

  this.LSHIFT = 24;

  this.URSHIFT = 25;

  this.RSHIFT = 26;

  this.LTE = 27;

  this.GTE = 28;

  this.LT = 29;

  this.GT = 30;

  this.EQ = 31;

  this.NEQ = 32;

  this.NOT = 33;

  this.BNEG = 34;

  this.BAND = 35;

  this.BXOR = 36;

  this.BOR = 37;

  this.AND = 38;

  this.OR = 39;

  this.ROT = 40;

  this.DUP = 41;

  this.TYPEOF = 42;

  this.NRET = 43;

}).call(this);

},{}],9:[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = function(program) { return program; },
        peg$c2 = { type: "any", description: "any character" },
        peg$c3 = { type: "other", description: "whitespace" },
        peg$c4 = /^[\t\x0B\f ]/,
        peg$c5 = { type: "class", value: "[\\t\\x0B\\f ]", description: "[\\t\\x0B\\f ]" },
        peg$c6 = /^[\n\r\u2028\u2029]/,
        peg$c7 = { type: "class", value: "[\\n\\r\\u2028\\u2029]", description: "[\\n\\r\\u2028\\u2029]" },
        peg$c8 = { type: "other", description: "end of line" },
        peg$c9 = "\n",
        peg$c10 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c11 = "\r\n",
        peg$c12 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c13 = "\r",
        peg$c14 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c15 = "\u2028",
        peg$c16 = { type: "literal", value: "\u2028", description: "\"\\u2028\"" },
        peg$c17 = "\u2029",
        peg$c18 = { type: "literal", value: "\u2029", description: "\"\\u2029\"" },
        peg$c19 = { type: "other", description: "comment" },
        peg$c20 = "/*",
        peg$c21 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c22 = [],
        peg$c23 = void 0,
        peg$c24 = "*/",
        peg$c25 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c26 = "//",
        peg$c27 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c28 = { type: "other", description: "identifier" },
        peg$c29 = function(name) { return name; },
        peg$c30 = function(start, parts) {
              return start + parts.join("");
            },
        peg$c31 = "$",
        peg$c32 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c33 = "_",
        peg$c34 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c35 = /^[a-zA-Z]/,
        peg$c36 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
        peg$c37 = "break",
        peg$c38 = { type: "literal", value: "break", description: "\"break\"" },
        peg$c39 = "continue",
        peg$c40 = { type: "literal", value: "continue", description: "\"continue\"" },
        peg$c41 = "delete",
        peg$c42 = { type: "literal", value: "delete", description: "\"delete\"" },
        peg$c43 = "do",
        peg$c44 = { type: "literal", value: "do", description: "\"do\"" },
        peg$c45 = "else",
        peg$c46 = { type: "literal", value: "else", description: "\"else\"" },
        peg$c47 = "for",
        peg$c48 = { type: "literal", value: "for", description: "\"for\"" },
        peg$c49 = "function",
        peg$c50 = { type: "literal", value: "function", description: "\"function\"" },
        peg$c51 = "if",
        peg$c52 = { type: "literal", value: "if", description: "\"if\"" },
        peg$c53 = "in",
        peg$c54 = { type: "literal", value: "in", description: "\"in\"" },
        peg$c55 = "return",
        peg$c56 = { type: "literal", value: "return", description: "\"return\"" },
        peg$c57 = "typeof",
        peg$c58 = { type: "literal", value: "typeof", description: "\"typeof\"" },
        peg$c59 = "while",
        peg$c60 = { type: "literal", value: "while", description: "\"while\"" },
        peg$c61 = function(value) { return new node.NumericLiteral(value); },
        peg$c62 = function(value) { return new node.StringLiteral(value); },
        peg$c63 = function() { return new node.NullLiteral(); },
        peg$c64 = function() { return new node.BooleanLiteral(true); },
        peg$c65 = function() { return new node.BooleanLiteral(false); },
        peg$c66 = { type: "other", description: "number" },
        peg$c67 = function(literal) {
              return literal;
            },
        peg$c68 = ".",
        peg$c69 = { type: "literal", value: ".", description: "\".\"" },
        peg$c70 = null,
        peg$c71 = function(before, after, exponent) {
              return parseFloat(before + "." + after + exponent);
            },
        peg$c72 = function(after, exponent) {
              return parseFloat("." + after + exponent);
            },
        peg$c73 = function(before, exponent) {
              return parseFloat(before + exponent);
            },
        peg$c74 = "0",
        peg$c75 = { type: "literal", value: "0", description: "\"0\"" },
        peg$c76 = function(digit, digits) { return digit + digits; },
        peg$c77 = function(digits) { return digits.join(""); },
        peg$c78 = /^[0-9]/,
        peg$c79 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c80 = /^[1-9]/,
        peg$c81 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c82 = function(indicator, integer) {
              return indicator + integer;
            },
        peg$c83 = /^[eE]/,
        peg$c84 = { type: "class", value: "[eE]", description: "[eE]" },
        peg$c85 = /^[\-+]/,
        peg$c86 = { type: "class", value: "[\\-+]", description: "[\\-+]" },
        peg$c87 = function(sign, digits) { return sign + digits; },
        peg$c88 = /^[xX]/,
        peg$c89 = { type: "class", value: "[xX]", description: "[xX]" },
        peg$c90 = function(digits) { return parseInt("0x" + digits.join("")); },
        peg$c91 = /^[0-9a-fA-F]/,
        peg$c92 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c93 = { type: "other", description: "string" },
        peg$c94 = "\"",
        peg$c95 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c96 = "'",
        peg$c97 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c98 = function(parts) {
              return parts[1];
            },
        peg$c99 = function(chars) { return chars.join(""); },
        peg$c100 = "\\",
        peg$c101 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c102 = function(char_) { return char_;     },
        peg$c103 = function(sequence) { return sequence;  },
        peg$c104 = function(sequence) { return sequence; },
        peg$c105 = function() { return "\0"; },
        peg$c106 = /^['"\\bfnrtv]/,
        peg$c107 = { type: "class", value: "['\"\\\\bfnrtv]", description: "['\"\\\\bfnrtv]" },
        peg$c108 = function(char_) {
              return char_
                .replace("b", "\b")
                .replace("f", "\f")
                .replace("n", "\n")
                .replace("r", "\r")
                .replace("t", "\t")
                .replace("v", "\x0B") // IE does not recognize "\v".
            },
        peg$c109 = function(char_) { return char_; },
        peg$c110 = "x",
        peg$c111 = { type: "literal", value: "x", description: "\"x\"" },
        peg$c112 = "u",
        peg$c113 = { type: "literal", value: "u", description: "\"u\"" },
        peg$c114 = function(h1, h2) {
              return String.fromCharCode(parseInt("0x" + h1 + h2));
            },
        peg$c115 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
            },
        peg$c116 = function() { return "delete"; },
        peg$c117 = "false",
        peg$c118 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c119 = "null",
        peg$c120 = { type: "literal", value: "null", description: "\"null\"" },
        peg$c121 = "true",
        peg$c122 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c123 = function() { return "typeof"; },
        peg$c124 = ";",
        peg$c125 = { type: "literal", value: ";", description: "\";\"" },
        peg$c126 = "}",
        peg$c127 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c128 = function(name) { return new node.Variable(name); },
        peg$c129 = "(",
        peg$c130 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c131 = ")",
        peg$c132 = { type: "literal", value: ")", description: "\")\"" },
        peg$c133 = function(expression) { return expression; },
        peg$c134 = function(name, arguments) {
              return new node.FunctionCall(name, arguments);
            },
        peg$c135 = function(arguments) {
            return arguments ? arguments : [];
          },
        peg$c136 = ",",
        peg$c137 = { type: "literal", value: ",", description: "\",\"" },
        peg$c138 = function(head, tail) {
            var result = [head];
            for (var i = 0; i < tail.length; i++) {
              result.push(tail[i][3]);
            }
            return result;
          },
        peg$c139 = function(expression, operator) {
              return new node.PostfixExpression(operator, expression);
            },
        peg$c140 = "++",
        peg$c141 = { type: "literal", value: "++", description: "\"++\"" },
        peg$c142 = "--",
        peg$c143 = { type: "literal", value: "--", description: "\"--\"" },
        peg$c144 = function(operator, expression) {
              return new node.UnaryExpression(operator, expression);
            },
        peg$c145 = "+",
        peg$c146 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c147 = "-",
        peg$c148 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c149 = "~",
        peg$c150 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c151 = "!",
        peg$c152 = { type: "literal", value: "!", description: "\"!\"" },
        peg$c153 = function(head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = new node.BinaryExpression(
                    tail[i][1], result, tail[i][3]);
              }
              return result;
            },
        peg$c154 = "*",
        peg$c155 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c156 = "/",
        peg$c157 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c158 = "%",
        peg$c159 = { type: "literal", value: "%", description: "\"%\"" },
        peg$c160 = "=",
        peg$c161 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c162 = function(operator) { return operator; },
        peg$c163 = function() { return "+"; },
        peg$c164 = function() { return "-"; },
        peg$c165 = "<<",
        peg$c166 = { type: "literal", value: "<<", description: "\"<<\"" },
        peg$c167 = ">>>",
        peg$c168 = { type: "literal", value: ">>>", description: "\">>>\"" },
        peg$c169 = ">>",
        peg$c170 = { type: "literal", value: ">>", description: "\">>\"" },
        peg$c171 = "<=",
        peg$c172 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c173 = ">=",
        peg$c174 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c175 = "<",
        peg$c176 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c177 = ">",
        peg$c178 = { type: "literal", value: ">", description: "\">\"" },
        peg$c179 = "==",
        peg$c180 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c181 = "!=",
        peg$c182 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c183 = "&",
        peg$c184 = { type: "literal", value: "&", description: "\"&\"" },
        peg$c185 = function() { return "&"; },
        peg$c186 = "^",
        peg$c187 = { type: "literal", value: "^", description: "\"^\"" },
        peg$c188 = function() { return "^"; },
        peg$c189 = "|",
        peg$c190 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c191 = function() { return "|"; },
        peg$c192 = "&&",
        peg$c193 = { type: "literal", value: "&&", description: "\"&&\"" },
        peg$c194 = function() { return "&&"; },
        peg$c195 = "||",
        peg$c196 = { type: "literal", value: "||", description: "\"||\"" },
        peg$c197 = function() { return "||"; },
        peg$c198 = "?",
        peg$c199 = { type: "literal", value: "?", description: "\"?\"" },
        peg$c200 = ":",
        peg$c201 = { type: "literal", value: ":", description: "\":\"" },
        peg$c202 = function(condition, trueExpression, falseExpression) {
              return new node.ConditionalExpression(
                  condition, trueExpression, falseExpression);
            },
        peg$c203 = function(left, operator, right) {
              return new node.AssignmentExpression(operator, left, right);
            },
        peg$c204 = "*=",
        peg$c205 = { type: "literal", value: "*=", description: "\"*=\"" },
        peg$c206 = "/=",
        peg$c207 = { type: "literal", value: "/=", description: "\"/=\"" },
        peg$c208 = "%=",
        peg$c209 = { type: "literal", value: "%=", description: "\"%=\"" },
        peg$c210 = "+=",
        peg$c211 = { type: "literal", value: "+=", description: "\"+=\"" },
        peg$c212 = "-=",
        peg$c213 = { type: "literal", value: "-=", description: "\"-=\"" },
        peg$c214 = "<<=",
        peg$c215 = { type: "literal", value: "<<=", description: "\"<<=\"" },
        peg$c216 = ">>=",
        peg$c217 = { type: "literal", value: ">>=", description: "\">>=\"" },
        peg$c218 = ">>>=",
        peg$c219 = { type: "literal", value: ">>>=", description: "\">>>=\"" },
        peg$c220 = "&=",
        peg$c221 = { type: "literal", value: "&=", description: "\"&=\"" },
        peg$c222 = "^=",
        peg$c223 = { type: "literal", value: "^=", description: "\"^=\"" },
        peg$c224 = "|=",
        peg$c225 = { type: "literal", value: "|=", description: "\"|=\"" },
        peg$c226 = "{",
        peg$c227 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c228 = function(statements) {
              return new node.Block(statements ? statements[0] : []);
            },
        peg$c229 = function(head, tail) {
              var result = [head];
              for (var i = 0; i < tail.length; i++) {
                result.push(tail[i][1]);
              }
              return result;
            },
        peg$c230 = function(declarations) {
              return new node.VariableStatement(declarations);
            },
        peg$c231 = function(head, tail) {
              var result = [head];
              for (var i = 0; i < tail.length; i++) {
                result.push(tail[i][3]);
              }
              return result;
            },
        peg$c232 = function(name, value) {
              return new node.VariableDeclaration(name, value);
            },
        peg$c233 = function() { return new node.EmptyStatement(); },
        peg$c234 = function(condition, ifStatement, elseStatement) {
              return new node.IfStatement(condition, ifStatement,
                  elseStatement ? elseStatement[3] : null);
            },
        peg$c235 = function(statement, condition) {
              return new node.DoWhileStatement(condition, statement);
            },
        peg$c236 = function(condition, statement) {
              return new node.WhileStatement(condition, statement);
            },
        peg$c237 = function(declarations) {
                  return new node.VariableStatement(declarations);
                },
        peg$c238 = function(initializer, test, counter, statement) {
              return new node.ForStatement(
                  initializer ? initializer : null,
                  test ? test : null,
                  counter ? counter : null,
                  statement);
            },
        peg$c239 = function() {
              return new node.ContinueStatement();
            },
        peg$c240 = function() {
              return new node.BreakStatement();
            },
        peg$c241 = function() { return ""; },
        peg$c242 = function(value) {
              return new node.ReturnStatement(value ? value : null);
            },
        peg$c243 = function(name, params, elements) {
              return new node.Function_(
                  name, params ? params : [], elements);
            },
        peg$c244 = function(elements) { return elements ? elements : []; },
        peg$c245 = function(elements) {
              return new node.Program(elements ? elements : []);
            },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseProgram();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSourceCharacter() {
      var s0;

      if (input.length > peg$currPos) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }

      return s0;
    }

    function peg$parseWhiteSpace() {
      var s0, s1;

      peg$silentFails++;
      if (peg$c4.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }

      return s0;
    }

    function peg$parseLineTerminator() {
      var s0;

      if (peg$c6.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c7); }
      }

      return s0;
    }

    function peg$parseLineTerminatorSequence() {
      var s0, s1;

      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c9;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c11) {
          s0 = peg$c11;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c13;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c15;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c17;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }

      return s0;
    }

    function peg$parseComment() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$parseMultiLineComment();
      if (s0 === peg$FAILED) {
        s0 = peg$parseSingleLineComment();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }

      return s0;
    }

    function peg$parseMultiLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c20) {
        s1 = peg$c20;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c24) {
          s5 = peg$c24;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c23;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c24) {
            s5 = peg$c24;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c23;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c24) {
            s3 = peg$c24;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMultiLineCommentNoLineTerminator() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c20) {
        s1 = peg$c20;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c24) {
          s5 = peg$c24;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s5 === peg$FAILED) {
          s5 = peg$parseLineTerminator();
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c23;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c24) {
            s5 = peg$c24;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseLineTerminator();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c23;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c24) {
            s3 = peg$c24;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSingleLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c26) {
        s1 = peg$c26;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c23;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseLineTerminator();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c23;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseIdentifier() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseReservedWord();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c23;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifierName();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c29(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }

      return s0;
    }

    function peg$parseIdentifierName() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseIdentifierStart();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseIdentifierPart();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseIdentifierPart();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c30(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }

      return s0;
    }

    function peg$parseIdentifierStart() {
      var s0;

      s0 = peg$parseAlphaLetter();
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 36) {
          s0 = peg$c31;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 95) {
            s0 = peg$c33;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
        }
      }

      return s0;
    }

    function peg$parseIdentifierPart() {
      var s0;

      s0 = peg$parseIdentifierStart();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDecimalDigit();
      }

      return s0;
    }

    function peg$parseAlphaLetter() {
      var s0;

      if (peg$c35.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }

      return s0;
    }

    function peg$parseReservedWord() {
      var s0;

      s0 = peg$parseKeyword();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNullLiteral();
        if (s0 === peg$FAILED) {
          s0 = peg$parseBooleanLiteral();
        }
      }

      return s0;
    }

    function peg$parseKeyword() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c37) {
        s1 = peg$c37;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 8) === peg$c39) {
          s1 = peg$c39;
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c40); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c41) {
            s1 = peg$c41;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c43) {
              s1 = peg$c43;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c44); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c45) {
                s1 = peg$c45;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c46); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c47) {
                  s1 = peg$c47;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c48); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c49) {
                    s1 = peg$c49;
                    peg$currPos += 8;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c50); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c51) {
                      s1 = peg$c51;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c52); }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c53) {
                        s1 = peg$c53;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c54); }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c55) {
                          s1 = peg$c55;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c56); }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 6) === peg$c57) {
                            s1 = peg$c57;
                            peg$currPos += 6;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c58); }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c59) {
                              s1 = peg$c59;
                              peg$currPos += 5;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c60); }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLiteral() {
      var s0, s1;

      s0 = peg$parseNullLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseBooleanLiteral();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseNumericLiteral();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c61(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseStringLiteral();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c62(s1);
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parseNullLiteral() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNullToken();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c63();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseBooleanLiteral() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseTrueToken();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c64();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseFalseToken();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c65();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseNumericLiteral() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseHexIntegerLiteral();
      if (s1 === peg$FAILED) {
        s1 = peg$parseDecimalLiteral();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierStart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c67(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c66); }
      }

      return s0;
    }

    function peg$parseDecimalLiteral() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseDecimalIntegerLiteral();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c68;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDecimalDigits();
          if (s3 === peg$FAILED) {
            s3 = peg$c70;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseExponentPart();
            if (s4 === peg$FAILED) {
              s4 = peg$c70;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c71(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c68;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDecimalDigits();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExponentPart();
            if (s3 === peg$FAILED) {
              s3 = peg$c70;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c72(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDecimalIntegerLiteral();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponentPart();
            if (s2 === peg$FAILED) {
              s2 = peg$c70;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c73(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parseDecimalIntegerLiteral() {
      var s0, s1, s2;

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c74;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNonZeroDigit();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDecimalDigits();
          if (s2 === peg$FAILED) {
            s2 = peg$c70;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c76(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseDecimalDigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDecimalDigit();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseDecimalDigit();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c77(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDecimalDigit() {
      var s0;

      if (peg$c78.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c79); }
      }

      return s0;
    }

    function peg$parseNonZeroDigit() {
      var s0;

      if (peg$c80.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c81); }
      }

      return s0;
    }

    function peg$parseExponentPart() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseExponentIndicator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSignedInteger();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c82(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseExponentIndicator() {
      var s0;

      if (peg$c83.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }

      return s0;
    }

    function peg$parseSignedInteger() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c70;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDecimalDigits();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c87(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseHexIntegerLiteral() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 48) {
        s1 = peg$c74;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c88.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c89); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseHexDigit();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseHexDigit();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c90(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseHexDigit() {
      var s0;

      if (peg$c91.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }

      return s0;
    }

    function peg$parseStringLiteral() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c94;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDoubleStringCharacters();
        if (s3 === peg$FAILED) {
          s3 = peg$c70;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c94;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c95); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c96;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c97); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseSingleStringCharacters();
          if (s3 === peg$FAILED) {
            s3 = peg$c70;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s4 = peg$c96;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c97); }
            }
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c98(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }

      return s0;
    }

    function peg$parseDoubleStringCharacters() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDoubleStringCharacter();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseDoubleStringCharacter();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c99(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSingleStringCharacters() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseSingleStringCharacter();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseSingleStringCharacter();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c99(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDoubleStringCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c94;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c100;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c23;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c102(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c100;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c103(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseLineContinuation();
        }
      }

      return s0;
    }

    function peg$parseSingleStringCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 39) {
        s2 = peg$c96;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c97); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c100;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c23;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c102(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c100;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c101); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c103(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseLineContinuation();
        }
      }

      return s0;
    }

    function peg$parseLineContinuation() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLineTerminatorSequence();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c104(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEscapeSequence() {
      var s0, s1, s2, s3;

      s0 = peg$parseCharacterEscapeSequence();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c74;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c75); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parseDecimalDigit();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = peg$c23;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c105();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseHexEscapeSequence();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUnicodeEscapeSequence();
          }
        }
      }

      return s0;
    }

    function peg$parseCharacterEscapeSequence() {
      var s0;

      s0 = peg$parseSingleEscapeCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNonEscapeCharacter();
      }

      return s0;
    }

    function peg$parseSingleEscapeCharacter() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c106.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c107); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c108(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNonEscapeCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseEscapeCharacter();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c23;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseLineTerminator();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c109(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEscapeCharacter() {
      var s0;

      s0 = peg$parseSingleEscapeCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDecimalDigit();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 120) {
            s0 = peg$c110;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c111); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 117) {
              s0 = peg$c112;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseHexEscapeSequence() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 120) {
        s1 = peg$c110;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c111); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHexDigit();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseHexDigit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c114(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseUnicodeEscapeSequence() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 117) {
        s1 = peg$c112;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHexDigit();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseHexDigit();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHexDigit();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHexDigit();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c115(s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBreakToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c37) {
        s1 = peg$c37;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseContinueToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c39) {
        s1 = peg$c39;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseDeleteToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c41) {
        s1 = peg$c41;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c116();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseDoToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c43) {
        s1 = peg$c43;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseElseToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c45) {
        s1 = peg$c45;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFalseToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c117) {
        s1 = peg$c117;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c118); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseForToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c47) {
        s1 = peg$c47;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFunctionToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c49) {
        s1 = peg$c49;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseIfToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c51) {
        s1 = peg$c51;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseNullToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c119) {
        s1 = peg$c119;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c120); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseReturnToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c55) {
        s1 = peg$c55;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseTrueToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c121) {
        s1 = peg$c121;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c122); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseTypeofToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c57) {
        s1 = peg$c57;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c123();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseWhileToken() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c59) {
        s1 = peg$c59;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEOS() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c124;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c125); }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLineTerminatorSequence();
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c126;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c127); }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
              peg$currPos = s2;
              s2 = peg$c23;
            } else {
              s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse__();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseEOF();
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseEOSNoLineTerminator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c124;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c125); }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLineTerminatorSequence();
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c126;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c127); }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
              peg$currPos = s2;
              s2 = peg$c23;
            } else {
              s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseEOF();
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = peg$c23;
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseMultiLineCommentNoLineTerminator();
        if (s1 === peg$FAILED) {
          s1 = peg$parseSingleLineComment();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseWhiteSpace();
        if (s1 === peg$FAILED) {
          s1 = peg$parseMultiLineCommentNoLineTerminator();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSingleLineComment();
          }
        }
      }

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseLineTerminatorSequence();
        if (s1 === peg$FAILED) {
          s1 = peg$parseComment();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseWhiteSpace();
        if (s1 === peg$FAILED) {
          s1 = peg$parseLineTerminatorSequence();
          if (s1 === peg$FAILED) {
            s1 = peg$parseComment();
          }
        }
      }

      return s0;
    }

    function peg$parsePrimaryExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c128(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseLiteral();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c129;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c131;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c132); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c133(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parseCallExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseArguments();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c134(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseArguments() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c129;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c130); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseArgumentList();
          if (s3 === peg$FAILED) {
            s3 = peg$c70;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c131;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c132); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c135(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseArgumentList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAssignmentExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c136;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c137); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAssignmentExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c136;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c137); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAssignmentExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c138(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLeftHandSideExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c128(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePostfixExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseLeftHandSideExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePostfixOperator();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c139(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseCallExpression();
        if (s0 === peg$FAILED) {
          s0 = peg$parsePrimaryExpression();
        }
      }

      return s0;
    }

    function peg$parsePostfixOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c140) {
        s0 = peg$c140;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c141); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c142) {
          s0 = peg$c142;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c143); }
        }
      }

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3;

      s0 = peg$parsePostfixExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseUnaryOperator();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseUnaryExpression();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c144(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseUnaryOperator() {
      var s0;

      s0 = peg$parseDeleteToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseTypeofToken();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c140) {
            s0 = peg$c140;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c141); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c142) {
              s0 = peg$c142;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c143); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 43) {
                s0 = peg$c145;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c146); }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s0 = peg$c147;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c148); }
                }
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 126) {
                    s0 = peg$c149;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c150); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 33) {
                      s0 = peg$c151;
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c152); }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMultiplicativeOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseUnaryExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMultiplicativeOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseUnaryExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMultiplicativeOperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c154;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c155); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c156;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c157); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s1 = peg$c158;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c159); }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c160;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c161); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c162(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAdditiveOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMultiplicativeExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAdditiveOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMultiplicativeExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAdditiveOperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c145;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c146); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c145;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c146); }
        }
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c160;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c161); }
          }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c163();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c147;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c148); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c147;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c148); }
          }
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c160;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c161); }
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = peg$c23;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c164();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseShiftExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseShiftOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAdditiveExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseShiftOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAdditiveExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseShiftOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c165) {
        s0 = peg$c165;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c166); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c167) {
          s0 = peg$c167;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c168); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c169) {
            s0 = peg$c169;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c170); }
          }
        }
      }

      return s0;
    }

    function peg$parseRelationalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseShiftExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseRelationalOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseShiftExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseRelationalOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseShiftExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseRelationalOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c171) {
        s0 = peg$c171;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c172); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c173) {
          s0 = peg$c173;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c174); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 60) {
            s0 = peg$c175;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c176); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s0 = peg$c177;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c178); }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseEqualityExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseRelationalExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseEqualityOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseRelationalExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEqualityOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRelationalExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEqualityOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c179) {
        s0 = peg$c179;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c180); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c181) {
          s0 = peg$c181;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c182); }
        }
      }

      return s0;
    }

    function peg$parseBitwiseANDExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseEqualityExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseBitwiseANDOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseEqualityExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseBitwiseANDOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseEqualityExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBitwiseANDOperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        s1 = peg$c183;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c184); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 38) {
          s3 = peg$c183;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c184); }
        }
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c160;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c161); }
          }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c185();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBitwiseXORExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseBitwiseANDExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseBitwiseXOROperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseBitwiseANDExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseBitwiseXOROperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseBitwiseANDExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBitwiseXOROperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c186;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c187); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 94) {
          s3 = peg$c186;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c187); }
        }
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c160;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c161); }
          }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c188();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBitwiseORExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseBitwiseXORExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseBitwiseOROperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseBitwiseXORExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseBitwiseOROperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseBitwiseXORExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBitwiseOROperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c189;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c190); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 124) {
          s3 = peg$c189;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c190); }
        }
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c160;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c161); }
          }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c191();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLogicalANDExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseBitwiseORExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseLogicalANDOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseBitwiseORExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseLogicalANDOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseBitwiseORExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLogicalANDOperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c192) {
        s1 = peg$c192;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c193); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c160;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c161); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c194();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLogicalORExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseLogicalANDExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseLogicalOROperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseLogicalANDExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseLogicalOROperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseLogicalANDExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLogicalOROperator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c195) {
        s1 = peg$c195;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c196); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c160;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c161); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c197();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseConditionalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseLogicalORExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 63) {
            s3 = peg$c198;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c199); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c200;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c201); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseAssignmentExpression();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c202(s1, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLogicalORExpression();
      }

      return s0;
    }

    function peg$parseAssignmentExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseLeftHandSideExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseAssignmentOperator();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c203(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseConditionalExpression();
      }

      return s0;
    }

    function peg$parseAssignmentOperator() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c204) {
        s0 = peg$c204;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c205); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c206) {
          s0 = peg$c206;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c207); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c208) {
            s0 = peg$c208;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c209); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c210) {
              s0 = peg$c210;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c211); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c212) {
                s0 = peg$c212;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c213); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c214) {
                  s0 = peg$c214;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c215); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c216) {
                    s0 = peg$c216;
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c217); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c218) {
                      s0 = peg$c218;
                      peg$currPos += 4;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c219); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c220) {
                        s0 = peg$c220;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c221); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c222) {
                          s0 = peg$c222;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c223); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c224) {
                            s0 = peg$c224;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c225); }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAssignmentExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c136;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c137); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAssignmentExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c136;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c137); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAssignmentExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c153(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseStatement() {
      var s0;

      s0 = peg$parseBlock();
      if (s0 === peg$FAILED) {
        s0 = peg$parseVariableStatement();
        if (s0 === peg$FAILED) {
          s0 = peg$parseEmptyStatement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseExpressionStatement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseIfStatement();
              if (s0 === peg$FAILED) {
                s0 = peg$parseIterationStatement();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseContinueStatement();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseBreakStatement();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseReturnStatement();
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseBlock() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c226;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c227); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseStatementList();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c70;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s4 = peg$c126;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c127); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c228(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseStatementList() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseStatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseStatement();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseStatement();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c229(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableStatement() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseVariableDeclarationList();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOS();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c230(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableDeclarationList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseVariableDeclaration();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c136;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c137); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseVariableDeclaration();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c136;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c137); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseVariableDeclaration();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c231(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableDeclaration() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseInitialiser();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c232(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseInitialiser() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c160;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c161); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c160;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c161); }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c23;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseVariableDeclaration();
            if (s4 === peg$FAILED) {
              s4 = peg$parseAssignmentExpression();
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c133(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEmptyStatement() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c124;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c125); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c233();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseExpressionStatement() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c226;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c227); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$parseFunctionToken();
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c23;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseExpression();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOS();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c133(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseIfStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

      s0 = peg$currPos;
      s1 = peg$parseIfToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c129;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c131;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c132); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseStatement();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$currPos;
                        s11 = peg$parse__();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parseElseToken();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse__();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parseStatement();
                              if (s14 !== peg$FAILED) {
                                s11 = [s11, s12, s13, s14];
                                s10 = s11;
                              } else {
                                peg$currPos = s10;
                                s10 = peg$c0;
                              }
                            } else {
                              peg$currPos = s10;
                              s10 = peg$c0;
                            }
                          } else {
                            peg$currPos = s10;
                            s10 = peg$c0;
                          }
                        } else {
                          peg$currPos = s10;
                          s10 = peg$c0;
                        }
                        if (s10 === peg$FAILED) {
                          s10 = peg$c70;
                        }
                        if (s10 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c234(s5, s9, s10);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseIterationStatement() {
      var s0;

      s0 = peg$parseDoWhileStatement();
      if (s0 === peg$FAILED) {
        s0 = peg$parseWhileStatement();
        if (s0 === peg$FAILED) {
          s0 = peg$parseForStatement();
        }
      }

      return s0;
    }

    function peg$parseDoWhileStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      s1 = peg$parseDoToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseStatement();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseWhileToken();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s7 = peg$c129;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c130); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseExpression();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c131;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c132); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseEOS();
                            if (s12 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c235(s3, s9);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseWhileStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseWhileToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c129;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c131;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c132); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseStatement();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c236(s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseForStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

      s0 = peg$currPos;
      s1 = peg$parseForToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c129;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c130); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseVariableDeclarationList();
              if (s6 !== peg$FAILED) {
                peg$reportedPos = s5;
                s6 = peg$c237(s6);
              }
              s5 = s6;
              if (s5 === peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 === peg$FAILED) {
                  s5 = peg$c70;
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s7 = peg$c124;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c125); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseExpression();
                      if (s9 === peg$FAILED) {
                        s9 = peg$c70;
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 59) {
                            s11 = peg$c124;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c125); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse__();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseExpression();
                              if (s13 === peg$FAILED) {
                                s13 = peg$c70;
                              }
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parse__();
                                if (s14 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 41) {
                                    s15 = peg$c131;
                                    peg$currPos++;
                                  } else {
                                    s15 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c132); }
                                  }
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parse__();
                                    if (s16 !== peg$FAILED) {
                                      s17 = peg$parseStatement();
                                      if (s17 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c238(s5, s9, s13, s17);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseContinueStatement() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseContinueToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOSNoLineTerminator();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c239();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBreakStatement() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseBreakToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOSNoLineTerminator();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c240();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseReturnStatement() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseReturnToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseExpression();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEOS();
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c133(s4);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseEOSNoLineTerminator();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c241();
            }
            s3 = s4;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c242(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFunctionDeclaration() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

      s0 = peg$currPos;
      s1 = peg$parseFunctionToken();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s5 = peg$c129;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c130); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseFormalParameterList();
                  if (s7 === peg$FAILED) {
                    s7 = peg$c70;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s9 = peg$c131;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c132); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 123) {
                            s11 = peg$c226;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c227); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse__();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseFunctionBody();
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parse__();
                                if (s14 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 125) {
                                    s15 = peg$c126;
                                    peg$currPos++;
                                  } else {
                                    s15 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c127); }
                                  }
                                  if (s15 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c243(s3, s7, s13);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFormalParameterList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c136;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c137); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseIdentifier();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c136;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c137); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseIdentifier();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c231(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFunctionBody() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseFunctionElements();
      if (s1 === peg$FAILED) {
        s1 = peg$c70;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c244(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseProgram() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSourceElements();
      if (s1 === peg$FAILED) {
        s1 = peg$c70;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c245(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSourceElements() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseSourceElement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceElement();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceElement();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c229(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFunctionElements() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseStatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseStatement();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseStatement();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c229(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSourceElement() {
      var s0;

      s0 = peg$parseStatement();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFunctionDeclaration();
      }

      return s0;
    }


      node = require('./node');


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{"./node":7}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var ConstTable, FuncEntry, FuncTable, GlobalVars, LocalVars, SYM_FUNC, SYM_GLOBAL, SYM_LOCAL, SYM_NONE, SymTabEntry, SymTabSet, SymTable, _dictCount,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SYM_NONE = 0;

  SYM_LOCAL = 1;

  SYM_GLOBAL = 2;

  SYM_FUNC = 3;

  this.SYM_NONE = SYM_NONE;

  this.SYM_LOCAL = SYM_LOCAL;

  this.SYM_GLOBAL = SYM_GLOBAL;

  this.SYM_FUNC = SYM_FUNC;

  _dictCount = function(obj) {
    return Object.keys(obj).length;
  };

  ConstTable = (function() {
    function ConstTable() {
      this._set = new (require('./utils').Hashtable);
    }

    ConstTable.prototype.contains = function(obj) {
      return this._set.containsKey(obj);
    };

    ConstTable.prototype.put = function(obj) {
      if (!this._set.containsKey(obj)) {
        this._set.put(obj, this._set.size());
      }
      return this._set.get(obj);
    };

    ConstTable.prototype.count = function() {
      return this._set.size();
    };

    ConstTable.prototype.get = function(obj) {
      return this._set.get(obj);
    };

    ConstTable.prototype.forEach = function(cb, ctx) {
      if (ctx == null) {
        ctx = this;
      }
      return this._set.each(function(k, nr) {
        return cb.call(ctx, k, nr);
      });
    };

    return ConstTable;

  })();

  SymTabEntry = (function() {
    function SymTabEntry(flag, number) {
      this.flag = flag;
      this.number = number;
    }

    return SymTabEntry;

  })();

  FuncEntry = (function() {
    function FuncEntry(flag, argc, number) {
      this.flag = flag;
      this.argc = argc;
      this.number = number;
    }

    return FuncEntry;

  })();

  SymTable = (function() {
    function SymTable() {
      this._dict = {};
    }

    SymTable.prototype._add = function(name, flag) {
      var ste;
      ste = new SymTabEntry(flag, this.count());
      return this._dict[name] = ste;
    };

    SymTable.prototype.count = function() {
      return _dictCount(this._dict);
    };

    SymTable.prototype.contains = function(name) {
      return name in this._dict;
    };

    SymTable.prototype.get = function(name) {
      return this._dict[name];
    };

    SymTable.prototype.forEach = function(cb, ctx) {
      var k, ste, _ref, _results;
      if (ctx == null) {
        ctx = this;
      }
      _ref = this._dict;
      _results = [];
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        ste = _ref[k];
        _results.push(cb.call(ctx, k, ste));
      }
      return _results;
    };

    return SymTable;

  })();

  GlobalVars = (function(_super) {
    __extends(GlobalVars, _super);

    function GlobalVars() {
      return GlobalVars.__super__.constructor.apply(this, arguments);
    }

    GlobalVars.prototype.add = function(name) {
      return this._add(name, SYM_GLOBAL);
    };

    return GlobalVars;

  })(SymTable);

  LocalVars = (function(_super) {
    __extends(LocalVars, _super);

    function LocalVars() {
      return LocalVars.__super__.constructor.apply(this, arguments);
    }

    LocalVars.prototype.add = function(name) {
      return this._add(name, SYM_LOCAL);
    };

    return LocalVars;

  })(SymTable);

  FuncTable = (function(_super) {
    __extends(FuncTable, _super);

    function FuncTable() {
      return FuncTable.__super__.constructor.apply(this, arguments);
    }

    FuncTable.prototype.add = function(name, argc) {
      var fe;
      fe = new FuncEntry(SYM_FUNC, argc, this.count());
      return this._dict[name] = fe;
    };

    return FuncTable;

  })(SymTable);

  SymTabSet = (function() {
    function SymTabSet() {
      this.globals = new GlobalVars();
      this.locals = {};
      this.consts = new ConstTable();
      this.funcs = new FuncTable();
      this.currentTab = this.globals;
    }

    SymTabSet.prototype.isGlobal = function(name) {
      return this.globals.contains(name);
    };

    SymTabSet.prototype.isFunc = function(name) {
      return this.funcs.contains(name);
    };

    SymTabSet.prototype.enter = function(table) {
      return this.currentTab = table;
    };

    SymTabSet.prototype.enterGlobal = function() {
      return this.currentTab = this.globals;
    };

    SymTabSet.prototype.addLocal = function(name) {
      var localTab;
      localTab = new LocalVars;
      this.locals[name] = localTab;
      return this.enter(localTab);
    };

    return SymTabSet;

  })();

  this.ConstTable = ConstTable;

  this.GlobalVars = GlobalVars;

  this.LocalVars = LocalVars;

  this.FuncTable = FuncTable;

  this.SymTabSet = SymTabSet;

  this.SymTabEntry = SymTabEntry;

}).call(this);

},{"./utils":12}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var BaseASTVisitor, ast,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ast = require('./node');

  BaseASTVisitor = (function() {
    function BaseASTVisitor() {}

    BaseASTVisitor.prototype.visitNumericLiteral = function(node) {};

    BaseASTVisitor.prototype.visitStringLiteral = function(node) {};

    BaseASTVisitor.prototype.visitNullLiteral = function(node) {};

    BaseASTVisitor.prototype.visitBooleanLiteral = function(node) {};

    BaseASTVisitor.prototype.visitVariable = function(node) {};

    BaseASTVisitor.prototype.visitFunctionCall = function(node) {};

    BaseASTVisitor.prototype.visitPostfixExpression = function(node) {};

    BaseASTVisitor.prototype.visitUnaryExpression = function(node) {};

    BaseASTVisitor.prototype.visitBinaryExpression = function(node) {};

    BaseASTVisitor.prototype.visitConditionalExpression = function(node) {};

    BaseASTVisitor.prototype.visitAssignmentExpression = function(node) {};

    BaseASTVisitor.prototype.visitBlock = function(node) {};

    BaseASTVisitor.prototype.visitVariableStatement = function(node) {};

    BaseASTVisitor.prototype.visitVariableDeclaration = function(node) {};

    BaseASTVisitor.prototype.visitEmptyStatement = function(node) {};

    BaseASTVisitor.prototype.visitIfStatement = function(node) {};

    BaseASTVisitor.prototype.visitDoWhileStatement = function(node) {};

    BaseASTVisitor.prototype.visitWhileStatement = function(node) {};

    BaseASTVisitor.prototype.visitForStatement = function(node) {};

    BaseASTVisitor.prototype.visitContinueStatement = function(node) {};

    BaseASTVisitor.prototype.visitBreakStatement = function(node) {};

    BaseASTVisitor.prototype.visitReturnStatement = function(node) {};

    BaseASTVisitor.prototype.visitFunction_ = function(node) {};

    BaseASTVisitor.prototype.visitProgram = function(node) {};

    BaseASTVisitor.prototype.visitParameters = function(array) {};

    BaseASTVisitor.prototype.enter = function(nodeName, node) {
      var _name;
      return typeof this[_name = 'enter' + nodeName] === "function" ? this[_name](node) : void 0;
    };

    return BaseASTVisitor;

  })();

  this.FirstPassVisitor = (function(_super) {
    __extends(FirstPassVisitor, _super);

    function FirstPassVisitor(tabSet) {
      this.tabSet = tabSet;
    }

    FirstPassVisitor.prototype.enterFunction_ = function(node) {
      this.tabSet.addLocal(node.name);
      this.tabSet.funcs.add(node.name, node.params.length);
      return node.symInfo = this.tabSet.funcs.get(node.name);
    };

    FirstPassVisitor.prototype.visitNumericLiteral = function(node) {
      return node.constNum = this.tabSet.consts.put(node.value);
    };

    FirstPassVisitor.prototype.visitStringLiteral = function(node) {
      return node.constNum = this.tabSet.consts.put(node.value);
    };

    FirstPassVisitor.prototype.visitNullLiteral = function(node) {
      return node.constNum = this.tabSet.consts.put(node.value);
    };

    FirstPassVisitor.prototype.visitBooleanLiteral = function(node) {
      return node.constNum = this.tabSet.consts.put(node.value);
    };

    FirstPassVisitor.prototype.visitVariable = function(node) {
      if (!this.tabSet.currentTab.contains(node.name)) {
        if (!this.tabSet.isGlobal(node.name)) {
          throw new Error("undefined variable '" + node.name + "'");
        } else {
          return node.symInfo = this.tabSet.globals.get(node.name);
        }
      } else {
        return node.symInfo = this.tabSet.currentTab.get(node.name);
      }
    };

    FirstPassVisitor.prototype.visitFunctionCall = function(node) {
      if (!this.tabSet.funcs.contains(node.name)) {
        throw new Error("undefined function '" + node.name + "'");
      }
      return node.symInfo = this.tabSet.funcs.get(node.name);
    };

    FirstPassVisitor.prototype.visitVariableDeclaration = function(node) {
      if (!this.tabSet.currentTab.contains(node.name)) {
        if (!this.tabSet.isGlobal(node.name)) {
          this.tabSet.currentTab.add(node.name);
          node.symInfo = this.tabSet.currentTab.get(node.name);
        }
        node.symInfo = this.tabSet.globals.get(node.name);
      }
      return node.symInfo = this.tabSet.currentTab.get(node.name);
    };

    FirstPassVisitor.prototype.visitFunction_ = function(node) {
      return this.tabSet.enterGlobal();
    };

    FirstPassVisitor.prototype.visitParameters = function(array) {
      var param, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        param = array[_i];
        _results.push(this.tabSet.currentTab.add(param));
      }
      return _results;
    };

    return FirstPassVisitor;

  })(BaseASTVisitor);

  this.SecondPassVisitor = (function(_super) {
    __extends(SecondPassVisitor, _super);

    function SecondPassVisitor(gen) {
      this.gen = gen;
    }

    SecondPassVisitor.prototype.visitVariable = function(node) {
      return node.genCode = this.gen.genVariable;
    };

    SecondPassVisitor.prototype.visitNumericLiteral = function(node) {
      return node.genCode = this.gen.genLiteral;
    };

    SecondPassVisitor.prototype.visitStringLiteral = function(node) {
      return node.genCode = this.gen.genLiteral;
    };

    SecondPassVisitor.prototype.visitNullLiteral = function(node) {
      return node.genCode = this.gen.genLiteral;
    };

    SecondPassVisitor.prototype.visitBooleanLiteral = function(node) {
      return node.genCode = this.gen.genLiteral;
    };

    SecondPassVisitor.prototype.visitFunctionCall = function(node) {
      return node.genCode = this.gen.genFunctionCall;
    };

    SecondPassVisitor.prototype.visitPostfixExpression = function(node) {
      return node.genCode = this.gen.genPostfixExpression;
    };

    SecondPassVisitor.prototype.visitUnaryExpression = function(node) {
      return node.genCode = this.gen.genUnaryExpression;
    };

    SecondPassVisitor.prototype.visitBinaryExpression = function(node) {
      return node.genCode = this.gen.genBinaryExpression;
    };

    SecondPassVisitor.prototype.visitConditionalExpression = function(node) {
      return node.genCode = this.gen.genConditionalExpression;
    };

    SecondPassVisitor.prototype.visitAssignmentExpression = function(node) {
      return node.genCode = this.gen.genAssignmentExpression;
    };

    SecondPassVisitor.prototype.visitBlock = function(node) {
      return node.genCode = this.gen.genBlock;
    };

    SecondPassVisitor.prototype.visitVariableStatement = function(node) {
      return node.genCode = this.gen.genVariableStatement;
    };

    SecondPassVisitor.prototype.visitVariableDeclaration = function(node) {
      return node.genCode = this.gen.genVariableDeclaration;
    };

    SecondPassVisitor.prototype.visitEmptyStatement = function(node) {
      return node.genCode = this.gen.genEmptyStatement;
    };

    SecondPassVisitor.prototype.visitIfStatement = function(node) {
      return node.genCode = this.gen.genIfStatement;
    };

    SecondPassVisitor.prototype.visitDoWhileStatement = function(node) {
      return node.genCode = this.gen.genDoWhileStatement;
    };

    SecondPassVisitor.prototype.visitWhileStatement = function(node) {
      return node.genCode = this.gen.genWhileStatement;
    };

    SecondPassVisitor.prototype.visitForStatement = function(node) {
      return node.genCode = this.gen.genForStatement;
    };

    SecondPassVisitor.prototype.visitContinueStatement = function(node) {
      return node.genCode = this.gen.genContinueStatement;
    };

    SecondPassVisitor.prototype.visitBreakStatement = function(node) {
      return node.genCode = this.gen.genBreakStatement;
    };

    SecondPassVisitor.prototype.visitReturnStatement = function(node) {
      return node.genCode = this.gen.genReturnStatement;
    };

    SecondPassVisitor.prototype.visitFunction_ = function(node) {
      return node.genCode = this.gen.genFunction;
    };

    SecondPassVisitor.prototype.visitProgram = function(node) {
      return node.genCode = this.gen.genProgram;
    };

    return SecondPassVisitor;

  })(BaseASTVisitor);

}).call(this);

},{"./node":7}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var HashSet, Hashtable, mixinKeywords, printf, sprintf, vprintf, vsprintf,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  mixinKeywords = ['extended', 'included'];

  this.Mixins = (function() {
    function Mixins() {}

    Mixins["extends"] = function(obj) {
      var key, value, _ref;
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(mixinKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Mixins.include = function(obj) {
      var key, value, _ref;
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(mixinKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    return Mixins;

  })();

  sprintf = (function() {
	function get_type(variable) {
		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	}
	function str_repeat(input, multiplier) {
		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
		return output.join('');
	}

	var str_format = function() {
		if (!str_format.cache.hasOwnProperty(arguments[0])) {
			str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
		}
		return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
	};

	str_format.format = function(parse_tree, argv) {
		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
		for (i = 0; i < tree_length; i++) {
			node_type = get_type(parse_tree[i]);
			if (node_type === 'string') {
				output.push(parse_tree[i]);
			}
			else if (node_type === 'array') {
				match = parse_tree[i]; // convenience purposes only
				if (match[2]) { // keyword argument
					arg = argv[cursor];
					for (k = 0; k < match[2].length; k++) {
						if (!arg.hasOwnProperty(match[2][k])) {
							throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
						}
						arg = arg[match[2][k]];
					}
				}
				else if (match[1]) { // positional argument (explicit)
					arg = argv[match[1]];
				}
				else { // positional argument (implicit)
					arg = argv[cursor++];
				}

				if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
					throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
				}
				switch (match[8]) {
					case 'b': arg = arg.toString(2); break;
					case 'c': arg = String.fromCharCode(arg); break;
					case 'd': arg = parseInt(arg, 10); break;
					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
					case 'o': arg = arg.toString(8); break;
					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
					case 'u': arg = Math.abs(arg); break;
					case 'x': arg = arg.toString(16); break;
					case 'X': arg = arg.toString(16).toUpperCase(); break;
				}
				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
				pad_length = match[6] - String(arg).length;
				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
				output.push(match[5] ? arg + pad : pad + arg);
			}
		}
		return output.join('');
	};

	str_format.cache = {};

	str_format.parse = function(fmt) {
		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
		while (_fmt) {
			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
				parse_tree.push(match[0]);
			}
			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
				parse_tree.push('%');
			}
			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
				if (match[2]) {
					arg_names |= 1;
					var field_list = [], replacement_field = match[2], field_match = [];
					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
						field_list.push(field_match[1]);
						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
								field_list.push(field_match[1]);
							}
							else {
								throw('[sprintf] huh?');
							}
						}
					}
					else {
						throw('[sprintf] huh?');
					}
					match[2] = field_list;
				}
				else {
					arg_names |= 2;
				}
				if (arg_names === 3) {
					throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
				}
				parse_tree.push(match);
			}
			else {
				throw('[sprintf] huh?');
			}
			_fmt = _fmt.substring(match[0].length);
		}
		return parse_tree;
	};

	return str_format;
})();;

  vsprintf = function(fmt, argv) {
	argv.unshift(fmt);
	return sprintf.apply(null, argv);
};

  printf = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log(this.sprintf.apply(null, args));
  };

  vprintf = function(fmt, argv) {
    return console.log(this.vsprintf.call(null, fmt, argv));
  };

  this.sprintf = sprintf;

  this.vsprintf = vsprintf;

  this.printf = printf;

  this.vprintf = vprintf;

  Hashtable = (function() {
	var FUNCTION = "function";

	var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?
		function(arr, idx) {
			arr.splice(idx, 1);
		} :

		function(arr, idx) {
			var itemsAfterDeleted, i, len;
			if (idx === arr.length - 1) {
				arr.length = idx;
			} else {
				itemsAfterDeleted = arr.slice(idx + 1);
				arr.length = idx;
				for (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {
					arr[idx + i] = itemsAfterDeleted[i];
				}
			}
		};

	function hashObject(obj) {
		var hashCode;
		if (typeof obj == "string") {
			return obj;
		} else if (typeof obj.hashCode == FUNCTION) {
			// Check the hashCode method really has returned a string
			hashCode = obj.hashCode();
			return (typeof hashCode == "string") ? hashCode : hashObject(hashCode);
		} else if (typeof obj.toString == FUNCTION) {
			return obj.toString();
		} else {
			try {
				return String(obj);
			} catch (ex) {
				// For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when
				// passed to String()
				return Object.prototype.toString.call(obj);
			}
		}
	}

	function equals_fixedValueHasEquals(fixedValue, variableValue) {
		return fixedValue.equals(variableValue);
	}

	function equals_fixedValueNoEquals(fixedValue, variableValue) {
		return (typeof variableValue.equals == FUNCTION) ?
			   variableValue.equals(fixedValue) : (fixedValue === variableValue);
	}

	function createKeyValCheck(kvStr) {
		return function(kv) {
			if (kv === null) {
				throw new Error("null is not a valid " + kvStr);
			} else if (typeof kv == "undefined") {
				throw new Error(kvStr + " must not be undefined");
			}
		};
	}

	var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

	/*----------------------------------------------------------------------------------------------------------------*/

	function Bucket(hash, firstKey, firstValue, equalityFunction) {
        this[0] = hash;
		this.entries = [];
		this.addEntry(firstKey, firstValue);

		if (equalityFunction !== null) {
			this.getEqualityFunction = function() {
				return equalityFunction;
			};
		}
	}

	var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

	function createBucketSearcher(mode) {
		return function(key) {
			var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
			while (i--) {
				entry = this.entries[i];
				if ( equals(key, entry[0]) ) {
					switch (mode) {
						case EXISTENCE:
							return true;
						case ENTRY:
							return entry;
						case ENTRY_INDEX_AND_VALUE:
							return [ i, entry[1] ];
					}
				}
			}
			return false;
		};
	}

	function createBucketLister(entryProperty) {
		return function(aggregatedArr) {
			var startIndex = aggregatedArr.length;
			for (var i = 0, len = this.entries.length; i < len; ++i) {
				aggregatedArr[startIndex + i] = this.entries[i][entryProperty];
			}
		};
	}

	Bucket.prototype = {
		getEqualityFunction: function(searchValue) {
			return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
		},

		getEntryForKey: createBucketSearcher(ENTRY),

		getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

		removeEntryForKey: function(key) {
			var result = this.getEntryAndIndexForKey(key);
			if (result) {
				arrayRemoveAt(this.entries, result[0]);
				return result[1];
			}
			return null;
		},

		addEntry: function(key, value) {
			this.entries[this.entries.length] = [key, value];
		},

		keys: createBucketLister(0),

		values: createBucketLister(1),

		getEntries: function(entries) {
			var startIndex = entries.length;
			for (var i = 0, len = this.entries.length; i < len; ++i) {
				// Clone the entry stored in the bucket before adding to array
				entries[startIndex + i] = this.entries[i].slice(0);
			}
		},

		containsKey: createBucketSearcher(EXISTENCE),

		containsValue: function(value) {
			var i = this.entries.length;
			while (i--) {
				if ( value === this.entries[i][1] ) {
					return true;
				}
			}
			return false;
		}
	};

	/*----------------------------------------------------------------------------------------------------------------*/

	// Supporting functions for searching hashtable buckets

	function searchBuckets(buckets, hash) {
		var i = buckets.length, bucket;
		while (i--) {
			bucket = buckets[i];
			if (hash === bucket[0]) {
				return i;
			}
		}
		return null;
	}

	function getBucketForHash(bucketsByHash, hash) {
		var bucket = bucketsByHash[hash];

		// Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
		return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;
	}

	/*----------------------------------------------------------------------------------------------------------------*/

	function Hashtable(hashingFunctionParam, equalityFunctionParam) {
		var that = this;
		var buckets = [];
		var bucketsByHash = {};

		var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;
		var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;

		this.put = function(key, value) {
			checkKey(key);
			checkValue(value);
			var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;

			// Check if a bucket exists for the bucket key
			bucket = getBucketForHash(bucketsByHash, hash);
			if (bucket) {
				// Check this bucket to see if it already contains this key
				bucketEntry = bucket.getEntryForKey(key);
				if (bucketEntry) {
					// This bucket entry is the current mapping of key to value, so replace old value and we're done.
					oldValue = bucketEntry[1];
					bucketEntry[1] = value;
				} else {
					// The bucket does not contain an entry for this key, so add one
					bucket.addEntry(key, value);
				}
			} else {
				// No bucket exists for the key, so create one and put our key/value mapping in
				bucket = new Bucket(hash, key, value, equalityFunction);
				buckets[buckets.length] = bucket;
				bucketsByHash[hash] = bucket;
			}
			return oldValue;
		};

		this.get = function(key) {
			checkKey(key);

			var hash = hashingFunction(key);

			// Check if a bucket exists for the bucket key
			var bucket = getBucketForHash(bucketsByHash, hash);
			if (bucket) {
				// Check this bucket to see if it contains this key
				var bucketEntry = bucket.getEntryForKey(key);
				if (bucketEntry) {
					// This bucket entry is the current mapping of key to value, so return the value.
					return bucketEntry[1];
				}
			}
			return null;
		};

		this.containsKey = function(key) {
			checkKey(key);
			var bucketKey = hashingFunction(key);

			// Check if a bucket exists for the bucket key
			var bucket = getBucketForHash(bucketsByHash, bucketKey);

			return bucket ? bucket.containsKey(key) : false;
		};

		this.containsValue = function(value) {
			checkValue(value);
			var i = buckets.length;
			while (i--) {
				if (buckets[i].containsValue(value)) {
					return true;
				}
			}
			return false;
		};

		this.clear = function() {
			buckets.length = 0;
			bucketsByHash = {};
		};

		this.isEmpty = function() {
			return !buckets.length;
		};

		var createBucketAggregator = function(bucketFuncName) {
			return function() {
				var aggregated = [], i = buckets.length;
				while (i--) {
					buckets[i][bucketFuncName](aggregated);
				}
				return aggregated;
			};
		};

		this.keys = createBucketAggregator("keys");
		this.values = createBucketAggregator("values");
		this.entries = createBucketAggregator("getEntries");

		this.remove = function(key) {
			checkKey(key);

			var hash = hashingFunction(key), bucketIndex, oldValue = null;

			// Check if a bucket exists for the bucket key
			var bucket = getBucketForHash(bucketsByHash, hash);

			if (bucket) {
				// Remove entry from this bucket for this key
				oldValue = bucket.removeEntryForKey(key);
				if (oldValue !== null) {
					// Entry was removed, so check if bucket is empty
					if (!bucket.entries.length) {
						// Bucket is empty, so remove it from the bucket collections
						bucketIndex = searchBuckets(buckets, hash);
						arrayRemoveAt(buckets, bucketIndex);
						delete bucketsByHash[hash];
					}
				}
			}
			return oldValue;
		};

		this.size = function() {
			var total = 0, i = buckets.length;
			while (i--) {
				total += buckets[i].entries.length;
			}
			return total;
		};

		this.each = function(callback) {
			var entries = that.entries(), i = entries.length, entry;
			while (i--) {
				entry = entries[i];
				callback(entry[0], entry[1]);
			}
		};

		this.putAll = function(hashtable, conflictCallback) {
			var entries = hashtable.entries();
			var entry, key, value, thisValue, i = entries.length;
			var hasConflictCallback = (typeof conflictCallback == FUNCTION);
			while (i--) {
				entry = entries[i];
				key = entry[0];
				value = entry[1];

				// Check for a conflict. The default behaviour is to overwrite the value for an existing key
				if ( hasConflictCallback && (thisValue = that.get(key)) ) {
					value = conflictCallback(key, thisValue, value);
				}
				that.put(key, value);
			}
		};

		this.clone = function() {
			var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);
			clone.putAll(that);
			return clone;
		};
	}

	return Hashtable;
})();;

  HashSet = function (hashingFunction, equalityFunction) {
    var hashTable = new Hashtable(hashingFunction, equalityFunction);

    this.add = function(o) {
        hashTable.put(o, true);
    };

    this.addAll = function(arr) {
        var i = arr.length;
        while (i--) {
            hashTable.put(arr[i], true);
        }
    };

    this.values = function() {
        return hashTable.keys();
    };

    this.remove = function(o) {
        return hashTable.remove(o) ? o : null;
    };

    this.contains = function(o) {
        return hashTable.containsKey(o);
    };

    this.clear = function() {
        hashTable.clear();
    };

    this.size = function() {
        return hashTable.size();
    };

    this.isEmpty = function() {
        return hashTable.isEmpty();
    };

    this.clone = function() {
        var h = new HashSet(hashingFunction, equalityFunction);
        h.addAll(hashTable.keys());
        return h;
    };

    this.intersection = function(hashSet) {
        var intersection = new HashSet(hashingFunction, equalityFunction);
        var values = hashSet.values(), i = values.length, val;
        while (i--) {
            val = values[i];
            if (hashTable.containsKey(val)) {
                intersection.add(val);
            }
        }
        return intersection;
    };

    this.union = function(hashSet) {
        var union = this.clone();
        var values = hashSet.values(), i = values.length, val;
        while (i--) {
            val = values[i];
            if (!hashTable.containsKey(val)) {
                union.add(val);
            }
        }
        return union;
    };

    this.isSubsetOf = function(hashSet) {
        var values = hashTable.keys(), i = values.length;
        while (i--) {
            if (!hashSet.contains(values[i])) {
                return false;
            }
        }
        return true;
    };
};

  this.HashSet = HashSet;

  this.Hashtable = Hashtable;

}).call(this);

},{}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var BuiltinFunction, LogoVM, UserFunction, op;

  op = require('./opcodes');

  BuiltinFunction = require('./codeObj').BuiltinFunction;

  UserFunction = require('./codeObj').UserFunction;

  LogoVM = (function() {
    function LogoVM(codeObj) {
      this.codeObj = codeObj;
      this.consts = this.codeObj.consts;
      this.globals = this._initGlobals();
    }

    LogoVM.prototype._initGlobals = function() {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.codeObj.globalNames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(void 0);
      }
      return _results;
    };

    LogoVM.prototype.run = function() {
      return this._run(this.codeObj.code);
    };

    LogoVM.prototype._run = function(code, localContext, funcName) {
      var i, len, pc, stack, _args, _callee, _func, _global, _local, _name, _x, _y;
      if (localContext == null) {
        localContext = this.globals;
      }
      stack = [];
      pc = 0;
      len = code.length;
      while (pc < len) {
        switch (code[pc]) {
          case op.HALT:
            return 0;
          case op.POP:
            stack.pop();
            break;
          case op.LDCONST:
            stack.push(this.consts[code[++pc]]);
            break;
          case op.LDLOCAL:
            _local = localContext[code[++pc]];
            if (typeof _local === 'undefined') {
              _name = this.codeObj.localNames[funcName][code[pc]];
              throw new Error("" + _name + " is not defined");
            }
            stack.push(_local);
            break;
          case op.LDGLOBAL:
            _global = this.globals[code[++pc]];
            if (typeof _global === 'undefined') {
              _name = this.codeObj.globalNames[code[pc]];
              throw new Error("" + _name + " is not defined");
            }
            stack.push(_global);
            break;
          case op.STLOCAL:
            localContext[code[++pc]] = stack[stack.length - 1];
            break;
          case op.STGLOBAL:
            this.globals[code[++pc]] = stack[stack.length - 1];
            break;
          case op.CALL:
            _func = this.codeObj.functions[code[++pc]];
            _args = (function() {
              var _i, _ref, _results;
              _results = [];
              for (i = _i = 0, _ref = _func.argc; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                _results.push(stack.pop());
              }
              return _results;
            })();
            if (_func instanceof BuiltinFunction) {
              stack.push(_func.invoke(_args));
            } else if (_func instanceof UserFunction) {
              _callee = this.codeObj.funcInfos[code[pc]].name;
              _func.invoke(((function(_this) {
                return function(code, args) {
                  var _i, _localContext, _ref;
                  _localContext = [];
                  for (i = _i = 0, _ref = _this.codeObj.localNames[_callee].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    _localContext.push(void 0);
                  }
                  [].splice.apply(_localContext, [0, _func.argc - 0].concat(args)), args;
                  return stack.push(_this._run(code, _localContext, _callee));
                };
              })(this)), _args);
            }
            break;
          case op.RET:
            return stack.pop();
          case op.JT:
            ++pc;
            if (stack.pop()) {
              pc = code[pc];
              continue;
            }
            break;
          case op.JF:
            ++pc;
            if (!stack.pop()) {
              pc = code[pc];
              continue;
            }
            break;
          case op.JMP:
            pc = code[++pc];
            continue;
          case op.ADD:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x + _y);
            break;
          case op.SUB:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x - _y);
            break;
          case op.MUL:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x * _y);
            break;
          case op.DIV:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x / _y);
            break;
          case op.MOD:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x % _y);
            break;
          case op.DELLOCAL:
            delete localContext[code[++pc]];
            break;
          case op.DELGLOBAL:
            delete this.globals[code[++pc]];
            stack.push(true);
            break;
          case op.INC:
            ++stack[stack.length - 1];
            break;
          case op.DEC:
            --stack[stack.length - 1];
            break;
          case op.POS:
            stack[stack.length - 1] = +stack[stack.length - 1];
            break;
          case op.NEG:
            stack[stack.length - 1] = -stack[stack.length - 1];
            break;
          case op.LSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x << _y);
            break;
          case op.URSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >>> _y);
            break;
          case op.RSHIFT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >> _y);
            break;
          case op.LTE:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x <= _y);
            break;
          case op.GTE:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x >= _y);
            break;
          case op.LT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x < _y);
            break;
          case op.GT:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x > _y);
            break;
          case op.EQ:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x === _y);
            break;
          case op.NEQ:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x !== _y);
            break;
          case op.NOT:
            stack[stack.length - 1] = !stack[stack.length - 1];
            break;
          case op.BNEG:
            stack[stack.length - 1] = ~stack[stack.length - 1];
            break;
          case op.BAND:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x & _y);
            break;
          case op.BXOR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x ^ _y);
            break;
          case op.BOR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x | _y);
            break;
          case op.AND:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x && _y);
            break;
          case op.OR:
            _y = stack.pop();
            _x = stack.pop();
            stack.push(_x || _y);
            break;
          case op.ROT:
            _x = stack.pop();
            _y = stack.pop();
            stack.push(_x);
            stack.push(_y);
            break;
          case op.DUP:
            stack.push(stack[stack.length - 1]);
            break;
          case op.TYPEOF:
            stack.push(typeof stack.pop);
            break;
          case op.NRET:
            return void 0;
          default:
            throw new Error("Invalid opcode " + code[pc]);
        }
        pc++;
      }
      return 0;
    };

    return LogoVM;

  })();

  this.LogoVM = LogoVM;

}).call(this);

},{"./codeObj":4,"./opcodes":8}],14:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],15:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],16:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],17:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/usr/local/share/npm/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":16,"/usr/local/share/npm/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":15,"inherits":14}]},{},[])